"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[232],{4371:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e=JSON.parse('{"key":"v-1fa12de2","path":"/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"MediaCodec 基础知识","slug":"mediacodec-基础知识","link":"#mediacodec-基础知识","children":[]},{"level":2,"title":"webrtc 中如何使用硬件编码器？","slug":"webrtc-中如何使用硬件编码器","link":"#webrtc-中如何使用硬件编码器","children":[]},{"level":2,"title":"webrtc 中编码器是如何初始化的？","slug":"webrtc-中编码器是如何初始化的","link":"#webrtc-中编码器是如何初始化的","children":[]},{"level":2,"title":"webrtc 中是如何将数据送入编码器的？","slug":"webrtc-中是如何将数据送入编码器的","link":"#webrtc-中是如何将数据送入编码器的","children":[]},{"level":2,"title":"webrtc 是如何获取编码后的数据？","slug":"webrtc-是如何获取编码后的数据","link":"#webrtc-是如何获取编码后的数据","children":[]},{"level":2,"title":"webrtc 是如何做码流控制的？","slug":"webrtc-是如何做码流控制的","link":"#webrtc-是如何做码流控制的","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"updatedTime":1689519943000,"contributors":[{"name":"make","email":"yang1001yk@gmail.com","commits":1}]},"filePathRelative":"pages/webrtc/WebRTC源码分析(二)Android视频硬件编码.md"}')},8338:(n,a,s)=>{s.r(a),s.d(a,{default:()=>x});var e=s(6252);const t=(0,e._)("h2",{id:"简介",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#简介","aria-hidden":"true"},"#"),(0,e.Uk)(" 简介")],-1),o=(0,e._)("p",null,"本文将重点介绍在 Android 平台上，WebRTC 是如何使用 MediaCodec 对视频数据进行编码，以及在整个编码过程中 webrtc native 与 java 的流程交互。",-1),p=(0,e._)("p",null,"本篇开始会先回顾一下 Andorid MediaCodec 的概念和基础使用，然后再跟着问题去源码中分析。",-1),c=(0,e._)("h2",{id:"mediacodec-基础知识",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#mediacodec-基础知识","aria-hidden":"true"},"#"),(0,e.Uk)(" MediaCodec 基础知识")],-1),i={href:"https://developer.android.com/reference/android/media/MediaCodec",target:"_blank",rel:"noopener noreferrer"},l=(0,e._)("code",null,"MediaExtractor",-1),u=(0,e._)("code",null,"MediaSync",-1),d=(0,e._)("code",null,"MediaMuxer",-1),r=(0,e._)("code",null,"MediaCrypto",-1),k=(0,e._)("code",null,"MediaDrm",-1),v=(0,e._)("code",null,"Image",-1),m=(0,e._)("code",null,"Surface",-1),f=(0,e._)("p",null,"以下是 MediaCodec 的一些关键概念和用法：",-1),b=(0,e.uE)('<li><p>创建和配置 MediaCodec：首先，需要根据所需的编解码器类型（例如 H.264、VP8、Opus 等）创建一个 MediaCodec 实例。接下来，通过 MediaFormat 对象指定编解码器的一些参数，如分辨率、帧率、码率等。然后，使用 <code>configure()</code> 方法配置 MediaCodec。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 1. 创建和配置 MediaCodec</span>\n            <span class="token class-name">MediaCodecInfo</span> codecInfo <span class="token operator">=</span> <span class="token function">selectCodec</span><span class="token punctuation">(</span><span class="token constant">MIME_TYPE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>codecInfo <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;No codec found for &quot;</span> <span class="token operator">+</span> <span class="token constant">MIME_TYPE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n            <span class="token class-name">MediaFormat</span> format <span class="token operator">=</span> <span class="token class-name">MediaFormat</span><span class="token punctuation">.</span><span class="token function">createVideoFormat</span><span class="token punctuation">(</span><span class="token constant">MIME_TYPE</span><span class="token punctuation">,</span> <span class="token constant">WIDTH</span><span class="token punctuation">,</span> <span class="token constant">HEIGHT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            format<span class="token punctuation">.</span><span class="token function">setInteger</span><span class="token punctuation">(</span><span class="token class-name">MediaFormat</span><span class="token punctuation">.</span><span class="token constant">KEY_COLOR_FORMAT</span><span class="token punctuation">,</span> <span class="token class-name">MediaCodecInfo<span class="token punctuation">.</span>CodecCapabilities<span class="token punctuation">.</span>COLOR_FormatSurface</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            format<span class="token punctuation">.</span><span class="token function">setInteger</span><span class="token punctuation">(</span><span class="token class-name">MediaFormat</span><span class="token punctuation">.</span><span class="token constant">KEY_BIT_RATE</span><span class="token punctuation">,</span> <span class="token constant">BIT_RATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            format<span class="token punctuation">.</span><span class="token function">setInteger</span><span class="token punctuation">(</span><span class="token class-name">MediaFormat</span><span class="token punctuation">.</span><span class="token constant">KEY_FRAME_RATE</span><span class="token punctuation">,</span> <span class="token constant">FRAME_RATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            format<span class="token punctuation">.</span><span class="token function">setInteger</span><span class="token punctuation">(</span><span class="token class-name">MediaFormat</span><span class="token punctuation">.</span><span class="token constant">KEY_I_FRAME_INTERVAL</span><span class="token punctuation">,</span> <span class="token constant">IFRAME_INTERVAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            encoder <span class="token operator">=</span> <span class="token class-name">MediaCodec</span><span class="token punctuation">.</span><span class="token function">createByCodecName</span><span class="token punctuation">(</span>codecInfo<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            encoder<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">MediaCodec</span><span class="token punctuation">.</span><span class="token constant">CONFIGURE_FLAG_ENCODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            encoder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to initialize encoder&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>输入和输出缓冲区：MediaCodec 有两个缓冲区队列，一个用于输入，另一个用于输出。输入缓冲区用于接收原始数据（例如从摄像头捕获的视频帧），输出缓冲区用于存储编码后的数据。在编解码过程中，需要将这些缓冲区填充或消费。</p><p><img src="http://devyk.top/2022/202304161447304.png" alt=""></p></li><li><p>编码器工作模式：MediaCodec 支持两种工作模式，分别是同步和异步。在同步模式下，需要手动管理输入和输出缓冲区。在异步模式下，通过设置回调函数（<code>MediaCodec.Callback</code>），可以在编解码事件发生时自动通知应用程序。</p><p><strong>同步：</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">MediaCodec</span> codec <span class="token operator">=</span> <span class="token class-name">MediaCodec</span><span class="token punctuation">.</span><span class="token function">createByCodecName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n codec<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token class-name">MediaFormat</span> outputFormat <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// option B</span>\n codec<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">int</span> inputBufferId <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">dequeueInputBuffer</span><span class="token punctuation">(</span>timeoutUs<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>inputBufferId <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">ByteBuffer</span> inputBuffer <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getInputBuffer</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// fill inputBuffer with valid data</span>\n    …\n    codec<span class="token punctuation">.</span><span class="token function">queueInputBuffer</span><span class="token punctuation">(</span>inputBufferId<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">int</span> outputBufferId <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">dequeueOutputBuffer</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>outputBufferId <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">ByteBuffer</span> outputBuffer <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputBuffer</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">MediaFormat</span> bufferFormat <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputFormat</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// option A</span>\n    <span class="token comment">// bufferFormat is identical to outputFormat</span>\n    <span class="token comment">// outputBuffer is ready to be processed or rendered.</span>\n    …\n    codec<span class="token punctuation">.</span><span class="token function">releaseOutputBuffer</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>outputBufferId <span class="token operator">==</span> <span class="token class-name">MediaCodec</span><span class="token punctuation">.</span><span class="token constant">INFO_OUTPUT_FORMAT_CHANGED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Subsequent data will conform to new format.</span>\n    <span class="token comment">// Can ignore if using getOutputFormat(outputBufferId)</span>\n    outputFormat <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// option B</span>\n  <span class="token punctuation">}</span>\n <span class="token punctuation">}</span>\n codec<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n codec<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>异步(推荐使用):</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">MediaCodec</span> codec <span class="token operator">=</span> <span class="token class-name">MediaCodec</span><span class="token punctuation">.</span><span class="token function">createByCodecName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token class-name">MediaFormat</span> mOutputFormat<span class="token punctuation">;</span> <span class="token comment">// member variable</span>\n codec<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MediaCodec<span class="token punctuation">.</span>Callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">void</span> <span class="token function">onInputBufferAvailable</span><span class="token punctuation">(</span><span class="token class-name">MediaCodec</span> mc<span class="token punctuation">,</span> <span class="token keyword">int</span> inputBufferId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">ByteBuffer</span> inputBuffer <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getInputBuffer</span><span class="token punctuation">(</span>inputBufferId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// fill inputBuffer with valid data</span>\n    …\n    codec<span class="token punctuation">.</span><span class="token function">queueInputBuffer</span><span class="token punctuation">(</span>inputBufferId<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n \n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">void</span> <span class="token function">onOutputBufferAvailable</span><span class="token punctuation">(</span><span class="token class-name">MediaCodec</span> mc<span class="token punctuation">,</span> <span class="token keyword">int</span> outputBufferId<span class="token punctuation">,</span> …<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">ByteBuffer</span> outputBuffer <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputBuffer</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">MediaFormat</span> bufferFormat <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputFormat</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// option A</span>\n    <span class="token comment">// bufferFormat is equivalent to mOutputFormat</span>\n    <span class="token comment">// outputBuffer is ready to be processed or rendered.</span>\n    …\n    codec<span class="token punctuation">.</span><span class="token function">releaseOutputBuffer</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n \n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">void</span> <span class="token function">onOutputFormatChanged</span><span class="token punctuation">(</span><span class="token class-name">MediaCodec</span> mc<span class="token punctuation">,</span> <span class="token class-name">MediaFormat</span> format<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Subsequent data will conform to new format.</span>\n    <span class="token comment">// Can ignore if using getOutputFormat(outputBufferId)</span>\n    mOutputFormat <span class="token operator">=</span> format<span class="token punctuation">;</span> <span class="token comment">// option B</span>\n  <span class="token punctuation">}</span>\n \n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    …\n  <span class="token punctuation">}</span>\n  <span class="token annotation punctuation">@Override</span>\n  <span class="token keyword">void</span> <span class="token function">onCryptoError</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    …\n  <span class="token punctuation">}</span>\n <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n codec<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>\n mOutputFormat <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// option B</span>\n codec<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token comment">// wait for processing to complete</span>\n codec<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n codec<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>',3),g=(0,e.uE)('<p>MediaCodec 与 Surface：对于视频编解码，MediaCodec 可以与 Surface 对象一起使用，以便使用 GPU 进行高效处理。通过将编解码器与 Surface 关联，可以将图像数据直接从 Surface 传输到编解码器，而无需在 CPU 和 GPU 之间复制数据。这可以提高性能并降低功耗。</p><p>可使用如下 api 进行创建一个输入 surface</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Surface</span> createInputSurface <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>',3),C={href:"https://github.com/google/grafika/blob/master/app/src/main/java/com/android/grafika/RecordFBOActivity.java",target:"_blank",rel:"noopener noreferrer"},E=(0,e._)("li",null,[(0,e._)("p",null,[(0,e.Uk)("开始和停止编解码：配置完 MediaCodec 后，调用 "),(0,e._)("code",null,"start()"),(0,e.Uk)(" 方法开始编解码过程。在完成编解码任务后，需要调用 "),(0,e._)("code",null,"stop()"),(0,e.Uk)(" 方法停止编解码器，并使用 "),(0,e._)("code",null,"release()"),(0,e.Uk)(" 方法释放资源。")])],-1),h=(0,e._)("li",null,[(0,e._)("p",null,"错误处理：在使用 MediaCodec 时，可能会遇到各种类型的错误，如不支持的编解码格式、资源不足等。为了确保应用程序的稳定性，需要妥善处理这些错误情况。")],-1),y=(0,e._)("p",null,"总之，MediaCodec 是 Android 中处理音视频编解码的关键组件。了解其基本概念和用法有助于构建高效、稳定的媒体应用程序。",-1),_=(0,e._)("h2",{id:"webrtc-中如何使用硬件编码器",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#webrtc-中如何使用硬件编码器","aria-hidden":"true"},"#"),(0,e.Uk)(" webrtc 中如何使用硬件编码器？")],-1),F=(0,e._)("p",null,"由于在 WebRTC 中优先使用的是 VP8 编码器，所以我们想要分析 Android 上硬件编码的流程，需要先支持 h264 的硬件编码",-1),w=(0,e.uE)('<li><p>创建 PeerConnectionFactory 时设置视频编码器</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>\n    private PeerConnectionFactory createPeerConnectionFactory() {\n        PeerConnectionFactory.initialize(\n                PeerConnectionFactory.InitializationOptions.builder(applicationContext)\n                        .setEnableInternalTracer(true)\n                        .createInitializationOptions());\n\n        PeerConnectionFactory.Options options = new PeerConnectionFactory.Options();\n        DefaultVideoEncoderFactory defaultVideoEncoderFactory =\n                new DefaultVideoEncoderFactory(\n                        rootEglBase.getEglBaseContext(), true /* enableIntelVp8Encoder */, true);\n        DefaultVideoDecoderFactory defaultVideoDecoderFactory =\n                new DefaultVideoDecoderFactory(rootEglBase.getEglBaseContext());\n\n        return PeerConnectionFactory.builder()\n                .setOptions(options)\n                .setVideoEncoderFactory(defaultVideoEncoderFactory)\n                .setVideoDecoderFactory(defaultVideoDecoderFactory)\n                .createPeerConnectionFactory();\n    }\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>',1),M=(0,e._)("p",null,"在 createOffer / createAnswer 将 SDP 中 m=video 的 h264 playload 编号放在第一位",-1),B={href:"https://github.com/yangkun19921001/OpenRTCClient/blob/develop/examples/android_gradle/AppRTCMobile/src/main/java/org/appspot/apprtc/PeerConnectionClient.java",target:"_blank",rel:"noopener noreferrer"},I=(0,e.uE)('<h2 id="webrtc-中编码器是如何初始化的" tabindex="-1"><a class="header-anchor" href="#webrtc-中编码器是如何初始化的" aria-hidden="true">#</a> webrtc 中编码器是如何初始化的？</h2><p>通过上一个问题得知，我们使用的是 <strong>DefaultVideoEncoderFactory</strong> 默认编码器，内容其实就是使用的硬件能力</p><p><img src="http://devyk.top/2022/202304161542395.png" alt=""></p><p>内部实例化了一个 <strong>HardwareVideoEncoderFactory</strong> ，我们在 <strong>DefaultVideoEncoderFactory</strong> 中看到了 <code>createEncoder</code> 函数，这里的内部就是实例化 HardwareVideoEncoder 的地方，我先 debug 下看下是哪里调用的，如下图所示，</p><p>下图的第一点可以发现底层传递过来的已经是 h264 编码器的信息了。</p><p><img src="http://devyk.top/2022/202304161631092.png" alt=""></p><p>发现调用栈并没有在 java 端，那肯定在 native 端了，我们可以通过 <strong>createPeerConnectionFactory</strong> 查看下调用</p>',7),j=(0,e.uE)('<li><p>将 videoEnvoderFactory 引用传递到 native</p><p><img src="http://devyk.top/2022/202304161631311.png" alt=""></p></li><li><p>Native 入口在 PeerConnectionFactory_jni.h</p><p><img src="http://devyk.top/2022/202304161633190.png" alt=""></p></li><li><p>根据调用栈，发现将 jencoder_factory 包装到了 <strong>CreateVideoEncoderFactory</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ScopedJavaLocalRef&lt;jobject&gt; CreatePeerConnectionFactoryForJava(\n    JNIEnv* jni,\n    const JavaParamRef&lt;jobject&gt;&amp; jcontext,\n    const JavaParamRef&lt;jobject&gt;&amp; joptions,\n    rtc::scoped_refptr&lt;AudioDeviceModule&gt; audio_device_module,\n    rtc::scoped_refptr&lt;AudioEncoderFactory&gt; audio_encoder_factory,\n    rtc::scoped_refptr&lt;AudioDecoderFactory&gt; audio_decoder_factory,\n    const JavaParamRef&lt;jobject&gt;&amp; jencoder_factory,\n    const JavaParamRef&lt;jobject&gt;&amp; jdecoder_factory,\n    rtc::scoped_refptr&lt;AudioProcessing&gt; audio_processor,\n    std::unique_ptr&lt;FecControllerFactoryInterface&gt; fec_controller_factory,\n    std::unique_ptr&lt;NetworkControllerFactoryInterface&gt;\n        network_controller_factory,\n    std::unique_ptr&lt;NetworkStatePredictorFactoryInterface&gt;\n        network_state_predictor_factory,\n    std::unique_ptr&lt;NetEqFactory&gt; neteq_factory) {\n\n...\n\n  media_dependencies.video_encoder_factory =\n      absl::WrapUnique(CreateVideoEncoderFactory(jni, jencoder_factory));\n\n...\n}\n\nVideoEncoderFactory* CreateVideoEncoderFactory(\n    JNIEnv* jni,\n    const JavaRef&lt;jobject&gt;&amp; j_encoder_factory) {\n  return IsNull(jni, j_encoder_factory)\n             ? nullptr\n             : new VideoEncoderFactoryWrapper(jni, j_encoder_factory);\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过一系列的调用，我们发现java 端的引用，被封装成了 c++ 端的 <strong>VideoEncoderFactoryWrapper</strong> ,我们看一下它的构造函数</p><p><img src="http://devyk.top/2022/202304161644418.png" alt=""></p><p>主要就是通过 jni 调用 java 端的代码，用以获取当前设备所支持的编码器和编码器的信息</p></li><li><p>猜测既然在 Native 中包装了 java 端 VideoEncoder.java 的引用，那么肯定也有对应的 CreateEncoder 函数</p><p><img src="http://devyk.top/2022/202304161653222.png" alt=""></p><p>我们在 video_encoder_factory_wrapper.h 中看到了我们想要的函数，我们看下它的实现</p><p><img src="http://devyk.top/2022/202304161657500.png" alt=""></p><p><img src="http://devyk.top/2022/202304161657499.png" alt=""> 这不就是我们找到了 createEncoder jni 调用的入口吗？那么是什么时候调用的呢？我们进行 debug 一下</p><p><img src="http://devyk.top/2022/202304161700450.png" alt=""></p><p>它的调用栈是媒体协商成功后，根据发起方的编码器来匹配，目前匹配到了最优的 H264 编码，然后进行创建 H264 编码器</p><p><img src="http://devyk.top/2022/202304161704320.gif" alt=""></p><p>此时，我们已经又回到了 java 端的 createEncoder 代码，我们来看下是怎么对 MediaCodec 初始化的</p></li>',5),O=(0,e.uE)('<p>MediaCodec 核心初始化代码</p><p>在 HardwareVideoEncoderFactory 中的 createEncoder 中</p><p><img src="http://devyk.top/2022/202304161708921.png" alt=""></p><p>上面的逻辑是判断 MediaCodec 是否只是 baseline 和 high ,如果都不支持返回空，反之返回 HardwareVideoEncoder 实例，该实例又返回给了 native ，然后转为了 native 的智能指针 <code>std::unique_ptr&lt;VideoEncoder&gt;</code> 的实体 VideoEncoderWrapper</p><p><img src="http://devyk.top/2022/202304161718584.png" alt=""></p><p>通过 <code>debug ，我们找到了在 native jni 执行 initEncode</code> 的入口函数</p><p><img src="http://devyk.top/2022/202304161719529.png" alt=""></p><p>通过媒体协商后，我们得到了编码器配置的一些参数</p><p><img src="http://devyk.top/2022/202304161723236.png" alt=""></p><p>内部执行了 <strong>initEncodeInternal</strong> ,我们看下具体实现</p><p><img src="http://devyk.top/2022/202304161730969.png" alt=""></p><p>这里就是我们所熟悉的 MediaCodec 编码配置了，根据上面的序号我们知道，先根据媒体协商后的编码器名称来创建一个 MediaCodec 对象，然后配置一些必要的参数，最后启动编码器.</p>',12),A={href:"https://juejin.cn/post/7139488477892050975#heading-4",target:"_blank",rel:"noopener noreferrer"},R=(0,e.uE)('<h2 id="webrtc-中是如何将数据送入编码器的" tabindex="-1"><a class="header-anchor" href="#webrtc-中是如何将数据送入编码器的" aria-hidden="true">#</a> webrtc 中是如何将数据送入编码器的？</h2><p>WebRTC 使用 <code>VideoEncoder</code> 接口来进行视频编码，该接口定义了一个用于编码视频帧的方法：<code>encode(VideoFrame frame, EncodeInfo info)</code>。WebRTC 提供了一个名为 <code>HardwareVideoEncoder</code> 的类，该类实现了 <code>VideoEncoder</code> 接口，并使用 MediaCodec 对视频帧进行编码。</p><p>在 <code>HardwareVideoEncoder</code> 类中，WebRTC 将 <code>VideoFrame</code> 对象转换为与 MediaCodec 关联的 <code>Surface</code> 的纹理。这是通过使用 <code>EglBase</code> 类创建一个 EGL 环境，并使用该环境将 <code>VideoFrame</code> 的纹理绘制到 <code>Surface</code> 上来实现的。</p><p>为了更好的理解 MediaCodec createInputSurface 和 OpenGL ES 、EGL 的关系，我简单画了一个架构图。如下所示:</p><p><img src="http://devyk.top/2022/202304162036455.png" alt=""></p><p>EGL、OpenGL ES、 InputSurface 关系流程：</p><ol><li>使用 OpenGL ES 绘制图像。</li><li>EGL 管理和连接 OpenGL ES 渲染的表面。</li><li>通过 Input Surface，将 OpenGL ES 绘制的图像传递给 MediaCodec。</li><li>MediaCodec 对接收到的图像数据进行编码。</li></ol>',7),V={href:"https://juejin.cn/post/7139488477892050975#heading-4",target:"_blank",rel:"noopener noreferrer"},T=(0,e.uE)('<p><img src="http://devyk.top/2022/202304161922718.png" alt=""></p><p>根据上面流程得知，采集到的 VideoFrame 会提交给 VideoStreamEncoder::OnFrame 然后经过调用 EncodeVideoFrame 会执行到 VideoEncoder.java 的包装类,webrtc::jni::VideoEnacoderWrapper::Encode 函数，最后通过 jni 将(videoFrame,encodeInfo) 回调给了 java 端。</p><p>接下来我们看 java 端如何处理的 VideoFrame</p><p><img src="http://devyk.top/2022/202304161936223.png" alt=""></p><p>该函数的核心是判断是否使用 surface 模式进行编码，如果条件成立调用 encodeTextureBuffer 进行纹理编码，</p><p><img src="http://devyk.top/2022/202304161940918.png" alt=""></p><p>我们先看上图的第一步,</p><p><img src="http://devyk.top/2022/202304161947167.png" alt=""></p><p>第一步的 1-3 小点主要是通过 OpenGL ES 将 OES 纹理数据绘制出来，然后第二大步的 <strong>textureEglBase.swapBuffers(...)</strong> 主要是将 OpenGL ES 处理后的图像数据提交给 EGLSurface 。经过这些操作后纹理数据就提交给 MediaCodec 的 inputsurface 了。</p><h2 id="webrtc-是如何获取编码后的数据" tabindex="-1"><a class="header-anchor" href="#webrtc-是如何获取编码后的数据" aria-hidden="true">#</a> webrtc 是如何获取编码后的数据？</h2><p>在 <code>HardwareVideoEncoder</code> 类中，使用 MediaCodec 同步模式进行获取编码后的数据。当数据可用时，会调用 <code>callback.onEncodedFrame(encodedImage, new CodecSpecificInfo());</code> 方法,然后将编码后的帧传递给 WebRTC 引擎。WebRTC 引擎会对编码后的帧进行进一步处理，如封装 RTP 包、发送到对端等。</p><p>主要流程如下:</p><p><img src="http://devyk.top/2022/202304162101149.png" alt=""></p><p>第一步有点印象吧？对，就是在编码器初始化的时候会开启一个循环获取解码数据的线程，我们分析下 deliverEncodedImage 函数的实现逻辑</p><p><img src="http://devyk.top/2022/202304162109204.png" alt=""></p><p>这段代码的主要功能是从编解码器 (MediaCodec) 中获取编码后的视频帧，并对关键帧进行处理。以下是代码的逐步分析：</p><ol><li><p>定义一个 <code>MediaCodec.BufferInfo</code> 对象，用于存储输出缓冲区的元信息。</p></li><li><p>调用 <code>codec.dequeueOutputBuffer()</code> 方法来获取编码后的输出缓冲区索引。如果索引小于 0，则有特殊含义。比如 <code>MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED</code> 表示输出缓冲区已更改，此时需要重新获取输出缓冲区。</p></li><li><p>使用索引获取编码后的输出缓冲区 (ByteBuffer)。</p></li><li><p>设置缓冲区的位置 (position) 和限制 (limit)，以便读取数据。</p></li><li><p>检查 <code>info.flags</code> 中的 <code>MediaCodec.BUFFER_FLAG_CODEC_CONFIG</code> 标志。如果存在，表示当前帧为编解码器配置帧。这种情况下，将配置帧数据存储在 <code>configBuffer</code> 中。</p></li><li><p>如果当前帧不是配置帧，则执行以下操作：</p><p>6.1 查看当前是否重新配置编码码率，如果是就更新比特率。</p><p>6.2 检查当前帧是否为关键帧。如果 <code>info.flags</code> 中的 <code>MediaCodec.BUFFER_FLAG_SYNC_FRAME</code> 标志存在，则表示当前帧为关键帧。 6.3 对于 H.264 编码的关键帧，将 SPS 和 PPS NALs 数据附加到帧的开头。创建一个新的缓冲区，将 <code>configBuffer</code> 和编码后的输出缓冲区的内容复制到新缓冲区中。</p><p>6.4 根据帧类型 (关键帧或非关键帧)，创建一个 <code>EncodedImage</code> 对象。在释放输出缓冲区时，确保不抛出任何异常。</p><p>6.5 调用 <code>callback.onEncodedFrame()</code> 方法传递编码后的图像和编解码器特定信息。</p><p>6.6 释放 <code>EncodedImage</code> 对象。</p></li></ol><p>当遇到异常 (例如 <code>IllegalStateException</code>) 时，代码将记录错误信息。</p><p>总之，这段代码的目标是从 MediaCodec 中获取编码后的视频帧，对关键帧进行处理，并将结果传递给回调函数。</p><p>对，该疑问的答案就是 6.5 它将编码后的数据通过 onEncodedFrame 告知了 webrtc 引擎。由于后面的处理不是本章的重点，所以不再分析。</p><h2 id="webrtc-是如何做码流控制的" tabindex="-1"><a class="header-anchor" href="#webrtc-是如何做码流控制的" aria-hidden="true">#</a> webrtc 是如何做码流控制的？</h2><p>WebRTC 的码流控制包括拥塞控制和比特率自适应两个主要方面。这里只简单介绍下概念，及 Android 是如何配合 webrtc 来动态修改码率的。</p><ol><li>拥塞控制 (Congestion Control)： 拥塞控制主要关注在不引起网络拥塞的情况下传输尽可能多的数据。WebRTC 实现了基于 Google Congestion Control (GCC) 的拥塞控制算法，它也被称为 Send Side Bandwidth Estimation（发送端带宽估计）。此算法根据丢包率、往返时间 (RTT) 和接收端的 ACK 信息来调整发送端的码率。拥塞控制算法会持续监测网络状况，并根据需要动态调整发送码率。</li><li>比特率自适应 (Bitrate Adaptation)： 比特率自适应关注如何根据网络条件和设备性能调整视频编码参数，以实现最佳的视频质量。</li></ol><p>当比特率发生变化时，WebRTC 会调用 <code>VideoEncoder.setRateAllocation()</code> 方法来通知更新比特率。</p><p>在编码的时候，其实在上一个疑问中已经知道了如何调节码率。判断条件是当当前的码率与需要调节的码率不匹配时，调用如下代码进行更新:</p><p><img src="http://devyk.top/2022/202304162147792.png" alt=""></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本文深入剖析了 WebRTC 在 Android 平台上是如何使用 MediaCodec 对视频数据进行编码的，以及整个编码过程中 webrtc native 与 java 的流程交互。首先回顾了 Android MediaCodec 的概念和基础使用，包括创建和配置 MediaCodec、输入和输出缓冲区、编码器工作模式以及 MediaCodec 与 Surface 的关系。然后，通过具体的代码示例，详细说明了在 WebRTC 中如何实现视频数据的编解码。并通过几个疑问的方式从源码的角度了解到了整个编码流程。希望通过此文能帮助读者更好地理解 WebRTC Android 编码技术。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',29),S={href:"https://blog.piasy.com/2017/08/08/WebRTC-Android-HW-Encode-Video/index.html",target:"_blank",rel:"noopener noreferrer"},U=(0,e._)("li",null,"https://developer.android.com/reference/android/media/MediaCodec.html",-1),P={},x=(0,s(3744).Z)(P,[["render",function(n,a){const s=(0,e.up)("ExternalLinkIcon");return(0,e.wg)(),(0,e.iD)("div",null,[t,o,p,c,(0,e._)("p",null,[(0,e._)("a",i,[(0,e.Uk)("MediaCodec"),(0,e.Wm)(s)]),(0,e.Uk)(" 是 Android 提供的一个用于处理音频和视频数据的底层 API。它支持编码（将原始数据转换为压缩格式）和解码（将压缩数据转换回原始格式）的过程。MediaCodec 是自 Android 4.1（API 16）起引入的，（通常与"),l,(0,e.Uk)("、"),u,(0,e.Uk)("、"),d,(0,e.Uk)("、"),r,(0,e.Uk)("、 "),k,(0,e.Uk)("、"),v,(0,e.Uk)("、"),m,(0,e.Uk)("一起使用）。")]),f,(0,e._)("ol",null,[b,(0,e._)("li",null,[g,(0,e._)("p",null,[(0,e.Uk)("返回的 inputSurface 可与 EGL 进行绑定，与 OpenGL ES 再进行关联。 sample 可以参考这个开源库 "),(0,e._)("a",C,[(0,e.Uk)("grafika"),(0,e.Wm)(s)])])]),E,h]),y,_,F,(0,e._)("ol",null,[w,(0,e._)("li",null,[M,(0,e._)("p",null,[(0,e.Uk)("这部分代码可以参考 "),(0,e._)("a",B,[(0,e.Uk)("preferCodec"),(0,e.Wm)(s)])])])]),I,(0,e._)("ol",null,[j,(0,e._)("li",null,[O,(0,e._)("p",null,[(0,e.Uk)("下一步我们开始分析 webrtc 如何将采集到的纹理送入到编码器中进行编码的。还没有看 "),(0,e._)("a",A,[(0,e.Uk)("WebRTC 源码分析 (一) Android 相机采集"),(0,e.Wm)(s)]),(0,e.Uk)(" 需要去温习一下。")])])]),R,(0,e._)("p",null,[(0,e.Uk)("我们看下具体的流程吧，通过上一篇文章得知， "),(0,e._)("a",V,[(0,e.Uk)("WebRTC 源码分析 (一) Android 相机采集"),(0,e.Wm)(s)]),(0,e.Uk)(" 采集到相机数据后，会提交给 VideoStreamEncoder ，我们来看一下堆栈")]),T,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e._)("a",S,[(0,e.Uk)("WebRTC Native 源码导读（三）：安卓视频硬编码实现分析"),(0,e.Wm)(s)])]),U])])}]])}}]);