"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[101],{3345:(n,e,s)=>{s.r(e),s.d(e,{data:()=>i});const i=JSON.parse('{"key":"v-362c9a50","path":"/pages/webrtc/WebRTC%E5%AE%9E%E6%88%98%20-%20QT%20for%20Windows%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"环境搭建","slug":"环境搭建","link":"#环境搭建","children":[{"level":3,"title":"1. QT 环境准备","slug":"_1-qt-环境准备","link":"#_1-qt-环境准备","children":[]},{"level":3,"title":"2. 信令服务器准备","slug":"_2-信令服务器准备","link":"#_2-信令服务器准备","children":[]},{"level":3,"title":"3. webrtc 静态库准备","slug":"_3-webrtc-静态库准备","link":"#_3-webrtc-静态库准备","children":[]},{"level":3,"title":"4. socketio-client-cpp 2.0.0 静态库准备","slug":"_4-socketio-client-cpp-2-0-0-静态库准备","link":"#_4-socketio-client-cpp-2-0-0-静态库准备","children":[]},{"level":3,"title":"5. QT cmake 编写","slug":"_5-qt-cmake-编写","link":"#_5-qt-cmake-编写","children":[]}]},{"level":2,"title":"如何构建多人音视频通话?","slug":"如何构建多人音视频通话","link":"#如何构建多人音视频通话","children":[{"level":3,"title":"1. 信令交互协议","slug":"_1-信令交互协议","link":"#_1-信令交互协议","children":[]},{"level":3,"title":"2. 本地信令交互封装","slug":"_2-本地信令交互封装","link":"#_2-本地信令交互封装","children":[]},{"level":3,"title":"3. 多 PeerConnection 管理","slug":"_3-多-peerconnection-管理","link":"#_3-多-peerconnection-管理","children":[]},{"level":3,"title":"4. 房间管理","slug":"_4-房间管理","link":"#_4-房间管理","children":[]},{"level":3,"title":"5. 如何显示","slug":"_5-如何显示","link":"#_5-如何显示","children":[]},{"level":3,"title":"6. 如何管理多个窗口的创建和销毁的","slug":"_6-如何管理多个窗口的创建和销毁的","link":"#_6-如何管理多个窗口的创建和销毁的","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1689560498000,"contributors":[{"name":"DevYK","email":"919079498@qq.com","commits":1}]},"filePathRelative":"pages/webrtc/WebRTC实战 - QT for Windows 实现多人音视频通话.md"}')},2791:(n,e,s)=>{s.r(e),s.d(e,{default:()=>r});var i=s(6252);const a=(0,i._)("h2",{id:"简介",tabindex:"-1"},[(0,i._)("a",{class:"header-anchor",href:"#简介","aria-hidden":"true"},"#"),(0,i.Uk)(" 简介")],-1),t={href:"https://chromiumdash.appspot.com/branches",target:"_blank",rel:"noopener noreferrer"},l=(0,i.uE)('<p>项目地址:https://github.com/yangkun19921001/OpenRTCClient/tree/develop/examples/p2ps/p2ps</p><p>最终与 Android、Web 端运行后的效果如下:</p><p><img src="http://devyk.top/2022/202307161407292.jpg" alt="img_v2_2460f4ab-2447-4694-9771-45d5846f471g"></p><h2 id="环境搭建" tabindex="-1"><a class="header-anchor" href="#环境搭建" aria-hidden="true">#</a> 环境搭建</h2><h3 id="_1-qt-环境准备" tabindex="-1"><a class="header-anchor" href="#_1-qt-环境准备" aria-hidden="true">#</a> 1. QT 环境准备</h3><p>首选我们去下载 QT 6.6.0 最新版本，下载地址为: https://www.qt.io/download ,安装好后选择 cmake 进行构建项目</p><h3 id="_2-信令服务器准备" tabindex="-1"><a class="header-anchor" href="#_2-信令服务器准备" aria-hidden="true">#</a> 2. 信令服务器准备</h3><p><strong>2.1 clone 信令服务器代码</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> clone https://github.com/yangkun19921001/OpenRTCProject.git\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2.2 启动信令服务器</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>cd p2ps<span class="token operator">/</span>server\n\n<span class="token comment">//修改你自己的证书</span>\n<span class="token keyword">const</span> server <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">HTTPS</span> <span class="token operator">===</span> <span class="token string">&#39;true&#39;</span> <span class="token operator">?</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token literal-property property">key</span> <span class="token operator">:</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">&#39;./cert/rtcmedia.top.key&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">cert</span><span class="token operator">:</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">&#39;./cert/rtcmedia.top_bundle.pem&#39;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token operator">:</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">//执行启动命令</span>\n<span class="token punctuation">.</span><span class="token operator">/</span>server_run<span class="token punctuation">.</span>js\n<span class="token punctuation">.</span><span class="token operator">/</span>proxy_server_run<span class="token punctuation">.</span>js\n\n<span class="token comment">//查看是否启动成功</span>\nlsof <span class="token operator">-</span>i<span class="token operator">:</span><span class="token number">8880</span> 和 <span class="token number">443</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-webrtc-静态库准备" tabindex="-1"><a class="header-anchor" href="#_3-webrtc-静态库准备" aria-hidden="true">#</a> 3. webrtc 静态库准备</h3><ol><li>clone webrtc(m98) develop 代码</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone https://github.com/yangkun19921001/OpenRTCClient.git\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>按照 README 进行编译，编译完成后拿到静态库 build/win/debug/obj/webrtc.lib</li></ol><h3 id="_4-socketio-client-cpp-2-0-0-静态库准备" tabindex="-1"><a class="header-anchor" href="#_4-socketio-client-cpp-2-0-0-静态库准备" aria-hidden="true">#</a> 4. socketio-client-cpp 2.0.0 静态库准备</h3><p>按照官方文档进行编译，可参考:https://github.com/socketio/socket.io-client-cpp/blob/2.0.0/INSTALL.md#with-cmake</p><h3 id="_5-qt-cmake-编写" tabindex="-1"><a class="header-anchor" href="#_5-qt-cmake-编写" aria-hidden="true">#</a> 5. QT cmake 编写</h3><p>上序 4 步如果都准备好，那么就可以通过 cmake 进行将其依赖进来，如下所示:</p><div class="language-cmake line-numbers-mode" data-ext="cmake"><pre class="language-cmake"><code><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.5</span><span class="token punctuation">)</span>\n<span class="token keyword">project</span><span class="token punctuation">(</span>p2ps <span class="token property">VERSION</span> <span class="token number">0.1</span> LANGUAGES CXX<span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_AUTOUIC</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_AUTOMOC</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_AUTORCC</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="token boolean">ON</span><span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span>BUILD_TYPE debug<span class="token punctuation">)</span>\n<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">MSVC</span><span class="token punctuation">)</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">CMAKE_BUILD_TYPE</span> <span class="token operator">MATCHES</span> Debug<span class="token punctuation">)</span>\n        <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_FLAGS_DEBUG</span> <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CXX_FLAGS_DEBUG</span><span class="token punctuation">}</span></span> /MTd&quot;</span><span class="token punctuation">)</span>\n        <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_C_FLAGS_DEBUG</span> <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_C_FLAGS_DEBUG</span><span class="token punctuation">}</span></span> /MTd&quot;</span><span class="token punctuation">)</span>\n    <span class="token keyword">elseif</span><span class="token punctuation">(</span><span class="token variable">CMAKE_BUILD_TYPE</span> <span class="token operator">MATCHES</span> Release<span class="token punctuation">)</span>\n        <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_FLAGS_RELEASE</span> <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CXX_FLAGS_RELEASE</span><span class="token punctuation">}</span></span> /MT&quot;</span><span class="token punctuation">)</span>\n        <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_C_FLAGS_RELEASE</span> <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_C_FLAGS_RELEASE</span><span class="token punctuation">}</span></span> /MT&quot;</span><span class="token punctuation">)</span>\n        <span class="token comment">#set(BUILD_TYPE release)</span>\n    <span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span>WEBRTC_THIRD_PARTY_PATH <span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/../../../webrtc/third_party<span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span>LIBWEBRTC_INCLUDE_PATH <span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/../../../webrtc<span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span>LIBWEBRTC_BINARY_PATH <span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/../../../build_system/build/win/x64/<span class="token punctuation">${</span>BUILD_TYPE<span class="token punctuation">}</span>/obj<span class="token punctuation">)</span>\n\n<span class="token keyword">set</span><span class="token punctuation">(</span>DEPS_ROOT_PATH <span class="token punctuation">${</span><span class="token variable">CMAKE_CURRENT_SOURCE_DIR</span><span class="token punctuation">}</span>/deps<span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span>SOCKET_IO_BINARY_PATH  <span class="token punctuation">${</span>DEPS_ROOT_PATH<span class="token punctuation">}</span>/socketio/win/x64/<span class="token punctuation">${</span>BUILD_TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">set</span><span class="token punctuation">(</span>SOCKET_IO_INCLUDE_PATH  <span class="token punctuation">${</span>DEPS_ROOT_PATH<span class="token punctuation">}</span>/socketio/include<span class="token punctuation">)</span>\n\n<span class="token keyword">set</span><span class="token punctuation">(</span>JSONCPP_SOURCE\n    <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">WEBRTC_THIRD_PARTY_PATH</span><span class="token punctuation">}</span></span>/jsoncpp/source/src/lib_json/json_reader.cpp&quot;</span>\n    <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">WEBRTC_THIRD_PARTY_PATH</span><span class="token punctuation">}</span></span>/jsoncpp/source/src/lib_json/json_tool.h&quot;</span>\n    <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">WEBRTC_THIRD_PARTY_PATH</span><span class="token punctuation">}</span></span>/jsoncpp/source/src/lib_json/json_value.cpp&quot;</span>\n    <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">WEBRTC_THIRD_PARTY_PATH</span><span class="token punctuation">}</span></span>/jsoncpp/source/src/lib_json/json_writer.cpp&quot;</span>\n<span class="token punctuation">)</span>\n\n\n<span class="token keyword">target_include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span> <span class="token namespace">PUBLIC</span>\n        <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">LIBWEBRTC_INCLUDE_PATH</span><span class="token punctuation">}</span></span>&quot;</span>\n        <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">LIBWEBRTC_INCLUDE_PATH</span><span class="token punctuation">}</span></span>/third_party/abseil-cpp&quot;</span>\n        <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">LIBWEBRTC_INCLUDE_PATH</span><span class="token punctuation">}</span></span>/third_party/jsoncpp/source/include&quot;</span>\n        <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">LIBWEBRTC_INCLUDE_PATH</span><span class="token punctuation">}</span></span>/third_party/jsoncpp/generated&quot;</span>\n        <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">LIBWEBRTC_INCLUDE_PATH</span><span class="token punctuation">}</span></span>/third_party/libyuv/include&quot;</span>\n        <span class="token string">&quot;<span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">SOCKET_IO_INCLUDE_PATH</span><span class="token punctuation">}</span></span>&quot;</span>\n<span class="token punctuation">)</span>\n\n<span class="token keyword">add_definitions</span><span class="token punctuation">(</span>\n        <span class="token comment">#webrtc &amp; qt 冲突</span>\n        -DQT_DEPRECATED_WARNINGS\n        -DQT_NO_KEYWORDS\n\n        <span class="token comment">#jsoncpp</span>\n        -DJSON_USE_EXCEPTION=<span class="token number">0</span>\n        -DJSON_USE_NULLREF=<span class="token number">0</span>\n\n        <span class="token comment">#socketio</span>\n        <span class="token comment">#-DSIO_TLS</span>\n\n        -DUSE_AURA=<span class="token number">1</span>\n        -D_HAS_EXCEPTIONS=<span class="token number">0</span>\n        -D__STD_C\n        -D_CRT_RAND_S\n        -D_CRT_SECURE_NO_DEPRECATE\n        -D_SCL_SECURE_NO_DEPRECATE\n        -D_ATL_NO_OPENGL\n        -D_WINDOWS\n        -DCERT_CHAIN_PARA_HAS_EXTRA_FIELDS\n        -<span class="token variable">DPSAPI_VERSION</span>=<span class="token number">2</span>\n        -DWIN32\n        -D_SECURE_ATL\n        -DWINUWP\n        -D__WRL_NO_DEFAULT_LIB__\n <span class="token comment">#       -DWINAPI_FAMILY=WINAPI_FAMILY_PC_APP</span>\n        -DWIN10=_WIN32_WINNT_WIN10\n        -DWIN32_LEAN_AND_MEAN\n        -DNOMINMAX\n        -D_UNICODE\n        -DUNICODE\n        -<span class="token variable">DNTDDI_VERSION</span>=NTDDI_WIN10_RS2\n        -D_WIN32_WINNT=0x0A00\n        -DWINVER=0x0A00\n        -DDEBUG\n        -DNVALGRIND\n        -DDYNAMIC_ANNOTATIONS_ENABLED=<span class="token number">0</span>\n        -DWEBRTC_ENABLE_PROTOBUF=<span class="token number">0</span>\n        -DWEBRTC_INCLUDE_INTERNAL_AUDIO_DEVICE\n        -DRTC_ENABLE_VP9\n        -DHAVE_SCTP\n        -DWEBRTC_LIBRARY_IMPL\n        -DWEBRTC_NON_STATIC_TRACE_EVENT_HANDLERS=<span class="token number">0</span>\n        -DWEBRTC_WIN\n        -DABSL_ALLOCATOR_NOTHROW=<span class="token number">1</span>\n        -DHAVE_SCTP\n        -DWEBRTC_VIDEO_CAPTURE_WINRT<span class="token punctuation">)</span>\n        \n        <span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>p2ps <span class="token namespace">PRIVATE</span>\n        ...\n        <span class="token punctuation">${</span>SOCKET_IO_BINARY_PATH<span class="token punctuation">}</span>/sioclient.lib <span class="token punctuation">${</span>SOCKET_IO_BINARY_PATH<span class="token punctuation">}</span>/sioclient_tls.lib\n\n        <span class="token punctuation">${</span>LIBWEBRTC_BINARY_PATH<span class="token punctuation">}</span>/webrtc.lib\n        winmm.lib iphlpapi.lib wbemuuid.lib secur32.lib advapi32.lib Mmdevapi.lib\n        Mfuuid.lib msdmo.lib dmoguids.lib wmcodecdspuuid.lib  comdlg32.lib dbghelp.lib\n        dnsapi.lib gdi32.lib msimg32.lib odbc32.lib odbccp32.lib oleaut32.lib shell32.lib\n        shlwapi.lib user32.lib usp10.lib uuid.lib version.lib wininet.lib winmm.lib   \n        winspool.lib ws2_32.lib delayimp.lib kernel32.lib ole32.lib crypt32.lib\n        amstrmid.lib strmiids.lib\n<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，在 QT 项目中的 WebRTC 和 SocketIO 环境已经搭建完成了，这里为什么要搭建 SocketIO 呢？因为在之前的 web 、server、Android 都使用的是 socketio 开源库来做的信令通信，正好它又是跨平台的，所以就不再更换了。</p><h2 id="如何构建多人音视频通话" tabindex="-1"><a class="header-anchor" href="#如何构建多人音视频通话" aria-hidden="true">#</a> 如何构建多人音视频通话?</h2><p>要在 QT 中构建一个多人的音视频通话项目，必定要经过如下几个步骤</p><h3 id="_1-信令交互协议" tabindex="-1"><a class="header-anchor" href="#_1-信令交互协议" aria-hidden="true">#</a> 1. 信令交互协议</h3><p>server 端的信令其实设计的很简单，就三组信令，如下所示:</p><p>join &gt; joined ：加入房间和加入成功的通知 leave &gt; leaved：离开房间和离开成功的通知 message：交换 offer ,candidate</p><p>更加详细的流程可以参考下面的流程图 <img src="http://devyk.top/2022/202303221325023.png" alt=""></p><h3 id="_2-本地信令交互封装" tabindex="-1"><a class="header-anchor" href="#_2-本地信令交互封装" aria-hidden="true">#</a> 2. 本地信令交互封装</h3><p>首先定义 ISinnalClient.h 抽象接口</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>namespace PCS{\nclass ISignalClient {\npublic:\n    enum class SignalEvent {\n        JOINED = 0,\n        JOIN,\n        LEAVED,\n        LEAVE,\n        MESSAGE\n    };\n\n    static std::string SignalEventToString(SignalEvent event) {\n        switch(event) {\n        case SignalEvent::JOINED:  return &quot;joined&quot;;\n        case SignalEvent::LEAVED:  return &quot;leaved&quot;;\n        case SignalEvent::JOIN:    return &quot;join&quot;;\n        case SignalEvent::LEAVE:   return &quot;leave&quot;;\n        case SignalEvent::MESSAGE: return &quot;message&quot;;\n        default: return &quot;unknown&quot;;\n        }\n    }\n\n    /*连接服务端*/\n    virtual bool connect(const std::string url,OnSignalEventListener* listener) = 0;\n    /*加入会话*/\n    virtual void join(const std::string roomId) = 0;\n    /*离开会话*/\n    virtual void leave(const std::string roomId) = 0;\n    /*销毁 client */\n    virtual void release() = 0;\n    /*发送消息*/\n    virtual void sendMessage(const std::string roomId, const std::string remoteId, const std::string message) = 0;\n\n    virtual std::string getSocketId() = 0;\n    virtual ~ISignalClient() = default;\n};\n\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后 socketio 根据对应的 api 去封装实现即可，详细的使用，可以参考 https://github.com/yangkun19921001/OpenRTCClient/blob/develop/examples/p2ps/p2ps/src/common/SocketIoSignalClientImpl.cpp</p><h3 id="_3-多-peerconnection-管理" tabindex="-1"><a class="header-anchor" href="#_3-多-peerconnection-管理" aria-hidden="true">#</a> 3. 多 PeerConnection 管理</h3><p>多 PeerConnection 管理其实就是把每次加入房间的 Peer 添加到一个容器中，管理起来。这里我们可以定义一个 map 结构进行管理，核心 api 如下</p><p><strong>3.1 定义一个 PeerConnection 管理结构体</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>struct Peer\n{\n    Peer() {}\n    rtc::scoped_refptr&lt;webrtc::PeerConnectionInterface&gt; peer_conn_inter_;\n    std::unique_ptr&lt;PeerConnectionObserverImpl&gt; peer_conn_obser_impl_;\n    std::unique_ptr&lt;CreateSessionDescriptionObserImpl&gt; create_offer_sess_des_impl_;\n    std::unique_ptr&lt;CreateSessionDescriptionObserImpl&gt; create_answer_sess_des_impl_;\n};\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内部主要包含每个 PeerConnection 所需要的成员，然后通过 std::map 进行管理，如下所示</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>std::map&lt;std::string ,std::unique_ptr&lt;Peer&gt;&gt; peers_;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>map 中的key 就是连接到房间中的 id</p><p><strong>3.2 创建 PeerConnectionFactory</strong></p><p>通过如下核心代码即可创建出 PeerConnectionFactory</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>       peer_connection_factory_ = webrtc::CreatePeerConnectionFactory(\n           this-&gt;network_thread_.get() /* network_thread */,\n           this-&gt;worker_thread_.get() /* worker_thread */,\n           this-&gt;signaling_thread_.get(), /* signaling_thread */\n           nullptr /* default_adm */,\n           webrtc::CreateBuiltinAudioEncoderFactory(),\n           webrtc::CreateBuiltinAudioDecoderFactory(),\n           webrtc::CreateBuiltinVideoEncoderFactory(),\n           webrtc::CreateBuiltinVideoDecoderFactory(), nullptr /* audio_mixer */,\n           nullptr /* audio_processing */);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当创建成功后，再创建本地音视频轨道，后续会将本地音视频轨道添加到 PeerConnection 中</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>//音频轨道\n audio_track_  = peer_connection_factory_-&gt;CreateAudioTrack(\n        kAudioLabel, peer_connection_factory_-&gt;CreateAudioSource(\n            cricket::AudioOptions()));\n //视频轨道\n  rtc::scoped_refptr&lt;CameraCapturerTrackSource&gt; video_device =\n      CameraCapturerTrackSource::Create(1280,720,30);\n  video_track_ =\n      peer_connection_factory_-&gt;CreateVideoTrack(kVideoLabel, video_device);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.3 创建 PeerConnection</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>bool PeerManager::createPeerConnection(const std::string &amp;peerId, const webrtc::PeerConnectionInterface::RTCConfiguration &amp;config\n                                       ,  OnPeerManagerEvents* ets)\n{\n  RTC_LOG(LS_INFO) &lt;&lt;__FUNCTION__ &lt;&lt;&quot; peerId:&quot;&lt;&lt;peerId;\n  RTC_DCHECK(peer_connection_factory_);\n      std::unique_ptr&lt;PeerConnectionObserverImpl&gt; peer_conn_obimpl =\n          std::make_unique&lt;PeerConnectionObserverImpl&gt;(peerId,ets);\n      auto peerConnection = peer_connection_factory_-&gt;CreatePeerConnection(\n          config,\n          nullptr,\n          nullptr,\n          peer_conn_obimpl.get());\n      if (peerConnection) {\n          auto peer_ptr = std::make_unique&lt;Peer&gt;();\n          peer_ptr-&gt;peer_conn_inter_ = peerConnection;\n          peer_ptr-&gt;peer_conn_obser_impl_ =std::move(peer_conn_obimpl);\n          peers_[peerId] = std::move(peer_ptr);\n          if(video_track_)\n           peerConnection-&gt;AddTrack(video_track_, { kVideoLabel });\n           if(audio_track_)\n          peerConnection-&gt;AddTrack(audio_track_, { kAudioLabel });\n          return true;\n      }\n      return false;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由上面的代码得知，我们通过 <code>peer_connection_factory_-&gt;CreatePeerConnection</code> 就可以构建一个 PeerConnection ，并把之前创建出来的本地音视频轨道添加到 PeerConnection 中，最后我们将构建出来的 PeConn 缓存到 map 中，便于后续的处理。</p><p><strong>3.4 创建 offer</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void PeerManager::createOffer(const std::string &amp;peerId, OnPeerManagerEvents* ets)\n{\n  RTC_LOG(LS_INFO) &lt;&lt;__FUNCTION__ &lt;&lt;&quot; peerId:&quot;&lt;&lt;peerId;\n  auto it = peers_.find(peerId);\n  if (it != peers_.end() &amp;&amp; it-&gt;second-&gt;peer_conn_inter_ != nullptr) {\n      auto obs = std::make_unique&lt;CreateSessionDescriptionObserImpl&gt;(true,peerId,ets);\n      it-&gt;second-&gt;peer_conn_inter_-&gt;CreateOffer(obs.get(), webrtc::PeerConnectionInterface::RTCOfferAnswerOptions());\n      it-&gt;second-&gt;create_offer_sess_des_impl_ = std::move(obs);\n  }else {\n      RTC_LOG(LS_ERROR) &lt;&lt; __FUNCTION__ &lt;&lt;  &quot; peers_ not found id:&quot;&lt;&lt;peerId;\n\n  }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码，首先根据 peerId 从缓存中拿到对应的 PeerConnection ,然后再调用它内部的 api 来进行 CreateOffer</p><p><strong>3.5 设置本地/远端 SDP</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void PeerManager::setLocalDescription(const std::string &amp;peerId,webrtc::SessionDescriptionInterface *desc_ptr)\n{\n  RTC_LOG(LS_INFO) &lt;&lt;__FUNCTION__ &lt;&lt;&quot; peerId:&quot;&lt;&lt;peerId;\n  auto pt = peers_.find(peerId);\n  if (pt != peers_.end()) {\n      pt-&gt;second-&gt;peer_conn_inter_-&gt;SetLocalDescription(SetSessionDescriptionObserverImpl::Create(),desc_ptr);\n\n  }else {\n      RTC_LOG(LS_ERROR) &lt;&lt; __FUNCTION__ &lt;&lt;  &quot; peers_ not found id:&quot;&lt;&lt;peerId;\n\n  }\n}\n\nvoid PeerManager::setRemoteDescription(const std::string &amp;peerId,webrtc::SessionDescriptionInterface *desc_ptr)\n{\n  RTC_LOG(LS_INFO) &lt;&lt;__FUNCTION__ &lt;&lt;&quot; peerId:&quot;&lt;&lt;peerId;\n  auto pt = peers_.find(peerId);\n  if (pt != peers_.end()) {\n  pt-&gt;second-&gt;peer_conn_inter_-&gt;SetRemoteDescription(SetSessionDescriptionObserverImpl::Create(),desc_ptr);\n  }else {\n  RTC_LOG(LS_ERROR) &lt;&lt; __FUNCTION__ &lt;&lt;  &quot; peers_ not found id:&quot;&lt;&lt;peerId;\n\n  }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从缓存中拿到对应的 <code>PeerConnection</code> ,然后设置本地或远端的 sdp 描述信息</p><p><strong>3.6 创建 answer</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void PeerManager::createAnswer(const std::string &amp;peerId, OnPeerManagerEvents* ets)\n{\n RTC_LOG(LS_INFO) &lt;&lt;__FUNCTION__ &lt;&lt;&quot; peerId:&quot;&lt;&lt;peerId;\n  auto it = peers_.find(peerId);\n  if (it != peers_.end() &amp;&amp; it-&gt;second-&gt;peer_conn_inter_ != nullptr) {\n      auto obs = std::make_unique&lt;CreateSessionDescriptionObserImpl&gt;(false,peerId,ets);\n      it-&gt;second-&gt;peer_conn_inter_-&gt;CreateAnswer(obs.get(), webrtc::PeerConnectionInterface::RTCOfferAnswerOptions());\n      it-&gt;second-&gt;create_answer_sess_des_impl_ = std::move(obs);\n  }else {\n      RTC_LOG(LS_ERROR) &lt;&lt; __FUNCTION__ &lt;&lt;  &quot; peers_ not found id:&quot;&lt;&lt;peerId;\n\n  }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此处与上一步逻辑一样</p><p><strong>3.7 处理 ice</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void PeerManager::handleCandidate(std::string peerId, std::unique_ptr&lt;webrtc::IceCandidateInterface&gt; candidate)\n{\n      RTC_LOG(LS_INFO) &lt;&lt; __FUNCTION__ &lt;&lt;&quot; peerId:&quot;&lt;&lt;peerId;\n      auto pt = peers_.find(peerId);\n      if (pt != peers_.end()) {\n          pt-&gt;second-&gt;peer_conn_inter_-&gt;AddIceCandidate(\n              std::move(candidate),\n              [peerId](webrtc::RTCError error){\n                  if (error.ok()) {\n                      RTC_LOG(LS_INFO) &lt;&lt;&quot; peerId:&quot;&lt;&lt; peerId &lt;&lt; &quot; AddIceCandidate success.&quot;;\n                  } else {\n                      RTC_LOG(LS_INFO) &lt;&lt;&quot; peerId:&quot;&lt;&lt; peerId &lt;&lt; &quot;AddIceCandidate failed, error: &quot; &lt;&lt; error.message();\n                  }\n       });\n    }else {\n          RTC_LOG(LS_ERROR) &lt;&lt; __FUNCTION__ &lt;&lt;  &quot; peers_ not found id:&quot;&lt;&lt;peerId;\n\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也是从缓存中拿到对应的 PeerConnection ，然后将对方的候选者地址添加进去。</p><h3 id="_4-房间管理" tabindex="-1"><a class="header-anchor" href="#_4-房间管理" aria-hidden="true">#</a> 4. 房间管理</h3><p>定义 RTCRoomManager ，实现信令回调和PeerManager 回调，定义的核心 API 如下</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>\nnamespace PCS{\n\nclass RTCRoomManager : public OnSignalEventListener,public OnPeerManagerEvents {\npublic:\n    RTCRoomManager();\n    virtual ~RTCRoomManager();\n\n    //连接服务器\n    void connect(const std::string url,OnRoomStateChangeCallback* callback);\n    //设置本地轨道的回调监听\n    void setLocalTrackCallback(std::function&lt;void(std::string,int,int,rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt;)&gt; localVideoTrack);\n    //加入房间\n    void join(const std::string roomId);\n    //离开房间\n    void leave(const std::string roomId);\n    //销毁\n    void release();\n    //处理 ui 传递过来的 消息\n    void onUIMessage(Message msg);\n\nprivate:\n    //实现连接成功的处理代码\n    void onConnectSuccessful() override;\n    //实现正在连接的处理代码\n    void onConnecting() override ;\n    //实现连接错误的处理代码\n    void onConnectError(const std::string&amp; error) override ;\n    //实现已加入房间的处理代码\n    void onJoined(const std::string&amp; room, const std::string&amp; id, const std::vector&lt;std::string&gt;&amp; otherClientIds) override;\n    //实现离开房间的处理代码\n    void onLeaved(const std::string&amp; room, const std::string&amp; id) override ;\n    //实现接收到消息的处理代码\n    void onMessage(const std::string&amp; from, const std::string&amp; to, const std::string&amp; message) override ;\n\n    //当需要添加远端的轨道\n     void OnAddTrack(std::string peerid,\n                            rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver,\n                            const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp;\n                                streams)override;\n    //当删除远端的轨道\n     void OnRemoveTrack(std::string peerid,\n                               rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver) override;\n     // datachannel 消息\n     void OnDataChannel(std::string peerid,\n                               rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; channel) override;\n     //ice 消息                          \n     void OnIceCandidate(std::string peerid,const webrtc::IceCandidateInterface* candidate) override;\n     //offer or answer create 成功\n     void OnCreateSuccess(bool offer,std::string peerid,webrtc::SessionDescriptionInterface* desc) override;\n     //offer or answer create 失败\n     void OnCreateFailure(bool offer,std::string peerid,webrtc::RTCError error) override;\n\n\n\n\nprivate:\n    std::unique_ptr&lt;ISignalClient&gt; socket_signal_client_imp_;\n    std::unique_ptr&lt;PeerManager&gt; peer_manager_;\n    OnRoomStateChangeCallback * room_state_change_callback_;\n    std::function&lt;void(std::string,int,int,rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt;)&gt; local_track_callback_;\n    std::string room_id_;\n\n};\n\n} // end namespace PCS\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是核心 API, 它持有 <code>peer_manager</code>_、<code>socket_signal_client_imp_</code> ，分别是对 PeerConnection 和信令的交互。</p><p>比如现在 A 用户先进入房间，B 后进入房间，然后对它们的管理流程是这样的</p><ol><li>A 用户连接服务器 -&gt; 连接成功 -&gt;发起 join 信令-&gt;收到 joined 信令-&gt;createPeerConnectionFactory-&gt;摄像头开始采集-&gt;等待预览</li><li>B 用户连接服务器 -&gt; 连接成功 -&gt;发起 join 信令 -&gt;收到joined 信令(并带上了 A 用户在房间中的信息) -&gt;createPeerConnectionFactory-&gt;等待本地预览-&gt;createPeerConnection(A用户)</li><li>A 用户收到 B 用户 joined 加入房间的信令 -&gt; createOffer -&gt; 设置本地 SDP -&gt; 发送 本地 SDP offer 信令到服务器</li><li>B 用户收到 服务器转发过来的 A 用户的 offer 信令 -&gt; 设置远端的 SDP 信息 -&gt;CreateAnswer(A用户)-&gt;设置本地 SDP 信息 -&gt; 发送 answer 消息给 A</li><li>A 收到 B 发送的 answer 信令消息，调用 setRemoteDescription 函数将 B 的 SDP 设置进去</li><li>A,B 交换 candidate 消息，并将对方的 candidate 调用 AddIceCandidate 添加进去</li><li>到这一步后，就等待 onAddTrack 回调了，下一步就是如何将对方和本地的画面进行显示了</li></ol><h3 id="_5-如何显示" tabindex="-1"><a class="header-anchor" href="#_5-如何显示" aria-hidden="true">#</a> 5. 如何显示</h3><p>在 webrtc 架构中，是通过 <code>rtc::VideoSinkInterface&lt;webrtc::VideoFrame&gt;</code> 的 <code>onFrame</code> 虚函数进行通知需要新视频数据的渲染。</p><p>我们定义一个 VideoRendererWidget 然后实现 <code>rtc::VideoSinkInterface&lt;webrtc::VideoFrame&gt;</code> 的 onFrame 函数，如下所示:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>namespace PCS {\nclass VideoRendererWidget : public QOpenGLWidget, protected QOpenGLFunctions,\n                            public rtc::VideoSinkInterface&lt;webrtc::VideoFrame&gt;\n{\n    Q_OBJECT\n\npublic:\n    VideoRendererWidget(std::string peerId =&quot;&quot;,QWidget* parent = nullptr,webrtc::VideoTrackInterface *track =nullptr);\n    ~VideoRendererWidget();\n\npublic Q_SLOTS:\n    void PlayOneFrame();\n\nprotected:\n    void initializeGL() Q_DECL_OVERRIDE;\n    void resizeGL(int w, int h) Q_DECL_OVERRIDE;\n    void paintGL() Q_DECL_OVERRIDE;\n\n\n\npublic:\n    // VideoSinkInterface implementation\n    void OnFrame(const webrtc::VideoFrame&amp; frame) override;\n\n\nprivate:\n...\n\npublic:\n   webrtc::VideoTrackInterface*  video_track_;\n};\n\n}\n\nvoid VideoRendererWidget::OnFrame(const webrtc::VideoFrame &amp;video_frame)\n{\n    std::lock_guard&lt;std::mutex&gt; guard(renderer_mutex_);\n    rtc::scoped_refptr&lt;webrtc::I420BufferInterface&gt; buffer(\n        video_frame.video_frame_buffer()-&gt;ToI420());\n    if (video_frame.rotation() != webrtc::kVideoRotation_0) {\n        buffer = webrtc::I420Buffer::Rotate(*buffer, video_frame.rotation());\n    }\n\n    int width = buffer-&gt;width();\n    int height = buffer-&gt;height();\n\n    int ySize = width * height;\n    int uvSize = ySize / 4;  // For each U and V component\n\n    if(m_nVideoW == 0 &amp;&amp; m_nVideoH ==0)\n    {\n       if(!peer_id_.empty())  RTC_LOG(LS_INFO) &lt;&lt; __FUNCTION__ &lt;&lt; &quot; init w:&quot;&lt;&lt;width&lt;&lt;&quot; height:&quot;&lt;&lt;height &lt;&lt; &quot; peerId:&quot; &lt;&lt;peer_id_;\n    }\n\n    if(width != m_nVideoW &amp;&amp; height != m_nVideoH &amp;&amp; video_data_ != nullptr)\n    {\n         video_data_ .reset();\n\n        if(!peer_id_.empty()) RTC_LOG(LS_INFO) &lt;&lt; __FUNCTION__ &lt;&lt; &quot; change w:&quot;&lt;&lt;width&lt;&lt;&quot; height:&quot;&lt;&lt;height &lt;&lt; &quot; peerId:&quot; &lt;&lt;peer_id_;\n\n    }\n\n    if(video_data_ == nullptr){\n      video_data_ = std::make_unique&lt;uint8_t[]&gt;(width * height * 1.5); // Use make_unique to allocate array\n      if(!peer_id_.empty())\n      RTC_LOG(LS_INFO) &lt;&lt; __FUNCTION__ &lt;&lt; &quot; malloc Id:&quot;&lt;&lt;peer_id_&lt;&lt;&quot; width:&quot; &lt;&lt; width &lt;&lt;&quot; height:&quot;&lt;&lt;height;\n    }\n    memcpy(video_data_.get(), buffer-&gt;DataY(), ySize);\n    memcpy(video_data_.get() + ySize, buffer-&gt;DataU(), uvSize);\n    memcpy(video_data_.get() + ySize + uvSize, buffer-&gt;DataV(), uvSize);\n    m_nVideoW = width;\n    m_nVideoH = height;\n\n\n    // 刷新界面,触发paintGL接口\n    Q_EMIT PlayOneFrame();\n\n}\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们调用 PlayOneFrame 时，就可以通过 QOpenGL 来进行渲染 I420 YUV 数据了。</p><h3 id="_6-如何管理多个窗口的创建和销毁的" tabindex="-1"><a class="header-anchor" href="#_6-如何管理多个窗口的创建和销毁的" aria-hidden="true">#</a> 6. 如何管理多个窗口的创建和销毁的</h3><p>可以通过管理 PeerConnection 那样管理 VideoRendererWidget ,还是定义一个 map</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>std::map&lt;std::string, std::unique_ptr&lt;PCS::VideoRendererWidget&gt;&gt; video_renderer_widgets_;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据对方的 peerid 来进行缓存窗口，</p><p>当需要添加窗口时:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void MainWindow::addVideoRendererWidgetToMainWindow(std::string id, std::unique_ptr&lt;PCS::VideoRendererWidget&gt; renderer)\n{\n\n     const int itemsPerRow = 3;\n     std::unique_ptr&lt;PCS::VideoRendererWidget&gt; videoRenderer;\n     if(renderer == nullptr)\n        videoRenderer =  std::make_unique&lt;PCS::VideoRendererWidget&gt;();\n     else {\n        videoRenderer = std::move(renderer);\n     }\n     videoRenderer-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);\n     // 计算新的位置\n     int count = ui-&gt;gridLayout-&gt;count();\n     int row = count / itemsPerRow;\n     int column = count % itemsPerRow;\n\n     // 添加到 gridLayout 中\n     ui-&gt;gridLayout-&gt;addWidget(videoRenderer.get(),row,column);\n     //videoRenderer-&gt;setFixedSize(1280/3,720/3);\n     // 将 widget 添加到 map 中\n     video_renderer_widgets_.insert({id, std::move(videoRenderer)});\n\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当需要删除窗口时:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void MainWindow::removeVideoRendererWidgetFromMainWindow(std::string id)\n    {\n     // 从 layout 中移除 widget，并删除它\n     // 查找 widget\n     auto it = video_renderer_widgets_.find(id);\n     if (it != video_renderer_widgets_.end())\n     {\n        // 从 layout 中移除 widget\n        ui-&gt;gridLayout-&gt;removeWidget(it-&gt;second.get());\n\n        // 从 map 中移除并删除 widget\n        video_renderer_widgets_.erase(it);\n     }\n    }\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>我们通过简短的描述和一些基础的 api 来介绍了如何通过 QT webrtc 来构建一个多人的音视频通话的项目。由于本人对 QT 不是太熟悉，所以 UI 上还有少许 Bug 。但不影响核心 API 调用。</p><p>到此，通过本篇文章和之前的几篇文章我们已经实现了 Web 、Android 、Windows 之前的互通，后续会继续介绍 WebRTC 源码分析和实战项目的开发。</p>',80),d={},r=(0,s(3744).Z)(d,[["render",function(n,e){const s=(0,i.up)("ExternalLinkIcon");return(0,i.wg)(),(0,i.iD)("div",null,[a,(0,i._)("p",null,[(0,i.Uk)("在经过前面几篇文章对 "),(0,i._)("a",t,[(0,i.Uk)("WebRTC"),(0,i.Wm)(s)]),(0,i.Uk)(" 的描述，相信已经不需再过多对它介绍了。前面几篇文章我们实现了 Web 、Android 端的音视频通话项目，该篇我们使用 QT UI 框架搭建 Windows 端的多 P2P 音视频通话实战项目。")]),l])}]])}}]);