<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.66">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/logo.jpeg"><title>音视星空</title><meta name="description" content="探索音视频领域的知识宝库">
    <link rel="stylesheet" href="/AudioVideoBlog/assets/css/styles.8f5bfb09.css">
    <link rel="preload" href="/AudioVideoBlog/assets/js/runtime~app.05409ea8.js" as="script"><link rel="preload" href="/AudioVideoBlog/assets/css/styles.8f5bfb09.css" as="style"><link rel="preload" href="/AudioVideoBlog/assets/js/48.afaf53c5.js" as="script"><link rel="preload" href="/AudioVideoBlog/assets/js/app.d2cafc2e.js" as="script"><link rel="preload" href="/AudioVideoBlog/assets/js/v-1fa12de2.3e0cb076.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-ece945e2.9f89926c.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-05c19f3e.fa64e478.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-7d176b3f.bf8b9c87.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-62e77dfd.58480197.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-aa56bcde.d319d2c9.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-f70ceb1c.19c41cdf.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-6368adfc.72b9fe4a.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-362c9a50.4b83143a.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-06bb4a38.ec767255.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/512.bf2e40be.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-ba1464b6.b09f6787.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-c193d65e.b8b0d616.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-46c05055.9738291b.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-51d3b4c4.f3a2690c.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-967c21de.216668f9.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-99e5d31c.dd517209.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-166a2a94.ddd4a60b.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-8daa1a0e.239d52dc.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-b9af664c.2065ab84.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-e3476bb2.0dcf3e53.js" as="script"><link rel="prefetch" href="/AudioVideoBlog/assets/js/v-3706649a.d5ed2a01.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/AudioVideoBlog/" class=""><img class="logo" src="/AudioVideoBlog/images/logo.jpeg" alt="音视星空"><span class="site-name can-hide">音视星空</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/AudioVideoBlog/pages/home.md" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/AudioVideoBlog/pages/webrtc/README.md" class="" aria-label="WebRTC"><!--[--><!--]--> WebRTC <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/yangkun19921001/AudioVideoBlogDoc" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/AudioVideoBlog/pages/home.md" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/AudioVideoBlog/pages/webrtc/README.md" class="" aria-label="WebRTC"><!--[--><!--]--> WebRTC <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/yangkun19921001/AudioVideoBlogDoc" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/AudioVideoBlog/pages/webrtc/WebRTC%20P2P%20%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%BA%94%E7%94%A8.html" class="sidebar-item" aria-label="WebRTC P2P 原理分析：从原理到应用"><!--[--><!--]--> WebRTC P2P 原理分析：从原理到应用 <!--[--><!--]--></a><!----></li><li><a href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)Android%E7%9B%B8%E6%9C%BA%E9%87%87%E9%9B%86.html" class="sidebar-item" aria-label="WebRTC 源码分析 (一) Android 相机采集"><!--[--><!--]--> WebRTC 源码分析 (一) Android 相机采集 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="WebRTC源码分析(二)Android视频硬件编码"><!--[--><!--]--> WebRTC源码分析(二)Android视频硬件编码 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html#简介" class="router-link-active router-link-exact-active sidebar-item" aria-label="简介"><!--[--><!--]--> 简介 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html#mediacodec-基础知识" class="router-link-active router-link-exact-active sidebar-item" aria-label="MediaCodec 基础知识"><!--[--><!--]--> MediaCodec 基础知识 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html#webrtc-中如何使用硬件编码器" class="router-link-active router-link-exact-active sidebar-item" aria-label="webrtc 中如何使用硬件编码器？"><!--[--><!--]--> webrtc 中如何使用硬件编码器？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html#webrtc-中编码器是如何初始化的" class="router-link-active router-link-exact-active sidebar-item" aria-label="webrtc 中编码器是如何初始化的？"><!--[--><!--]--> webrtc 中编码器是如何初始化的？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html#webrtc-中是如何将数据送入编码器的" class="router-link-active router-link-exact-active sidebar-item" aria-label="webrtc 中是如何将数据送入编码器的？"><!--[--><!--]--> webrtc 中是如何将数据送入编码器的？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html#webrtc-是如何获取编码后的数据" class="router-link-active router-link-exact-active sidebar-item" aria-label="webrtc 是如何获取编码后的数据？"><!--[--><!--]--> webrtc 是如何获取编码后的数据？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html#webrtc-是如何做码流控制的" class="router-link-active router-link-exact-active sidebar-item" aria-label="webrtc 是如何做码流控制的？"><!--[--><!--]--> webrtc 是如何做码流控制的？ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html#总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)Android%E8%A7%86%E9%A2%91%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A0%81.html#参考" class="router-link-active router-link-exact-active sidebar-item" aria-label="参考"><!--[--><!--]--> 参考 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)PeerConnection%20Client.html" class="sidebar-item" aria-label="WebRTC源码分析(三)PeerConnection Client"><!--[--><!--]--> WebRTC源码分析(三)PeerConnection Client <!--[--><!--]--></a><!----></li><li><a href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)%20Android%E3%80%81IOS%E3%80%81Windows%20%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html" class="sidebar-item" aria-label="WebRTC源码分析(四) Android、IOS、Windows 视频数据流程分析"><!--[--><!--]--> WebRTC源码分析(四) Android、IOS、Windows 视频数据流程分析 <!--[--><!--]--></a><!----></li><li><a href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87%E7%9B%B8%E6%9C%BA%E9%87%87%E9%9B%86.html" class="sidebar-item" aria-label="WebRTC源码分析(五)苹果设备相机采集"><!--[--><!--]--> WebRTC源码分析(五)苹果设备相机采集 <!--[--><!--]--></a><!----></li><li><a href="/AudioVideoBlog/pages/webrtc/WebRTC%E5%AE%9E%E6%88%98%20-%20P2P%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D.html" class="sidebar-item" aria-label="WebRTC实战 - P2P音视频通话"><!--[--><!--]--> WebRTC实战 - P2P音视频通话 <!--[--><!--]--></a><!----></li><li><a href="/AudioVideoBlog/pages/webrtc/WebRTC%E5%AE%9E%E6%88%98%20-%20P2P%E6%9E%B6%E6%9E%84%E7%9A%84%E5%A4%9A%E4%BA%BA%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html" class="sidebar-item" aria-label="WebRTC 实战: P2P 架构的多人音视频通话解决方案"><!--[--><!--]--> WebRTC 实战: P2P 架构的多人音视频通话解决方案 <!--[--><!--]--></a><!----></li><li><a href="/AudioVideoBlog/pages/webrtc/WebRTC%E5%AE%9E%E6%88%98%20-%20QT%20for%20Windows%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D.html" class="sidebar-item" aria-label="WebRTC实战 - QT for Windows 实现多人音视频通话"><!--[--><!--]--> WebRTC实战 - QT for Windows 实现多人音视频通话 <!--[--><!--]--></a><!----></li><li><a href="/AudioVideoBlog/pages/webrtc/WebRTC%E5%AE%9E%E6%88%98%20-%20mediasoup%E6%9E%B6%E6%9E%84%E7%9A%84%E5%A4%9A%E4%BA%BA%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html" class="sidebar-item" aria-label="WebRTC 实战: mediasoup SFU 架构的多人音视频通话解决方案"><!--[--><!--]--> WebRTC 实战: mediasoup SFU 架构的多人音视频通话解决方案 <!--[--><!--]--></a><!----></li><li><a href="/AudioVideoBlog/pages/webrtc/%E6%9E%84%E5%BB%BA%20WebRTC%20for%20IOS%20AppRTCMobile%20%E9%A1%B9%E7%9B%AE.html" class="sidebar-item" aria-label="构建 WebRTC for IOS AppRTCMobile 项目"><!--[--><!--]--> 构建 WebRTC for IOS AppRTCMobile 项目 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>本文将重点介绍在 Android 平台上，WebRTC 是如何使用 MediaCodec 对视频数据进行编码，以及在整个编码过程中 webrtc native 与 java 的流程交互。</p><p>本篇开始会先回顾一下 Andorid MediaCodec 的概念和基础使用，然后再跟着问题去源码中分析。</p><h2 id="mediacodec-基础知识" tabindex="-1"><a class="header-anchor" href="#mediacodec-基础知识" aria-hidden="true">#</a> MediaCodec 基础知识</h2><p><a href="https://developer.android.com/reference/android/media/MediaCodec" target="_blank" rel="noopener noreferrer">MediaCodec<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 是 Android 提供的一个用于处理音频和视频数据的底层 API。它支持编码（将原始数据转换为压缩格式）和解码（将压缩数据转换回原始格式）的过程。MediaCodec 是自 Android 4.1（API 16）起引入的，（通常与<code>MediaExtractor</code>、<code>MediaSync</code>、<code>MediaMuxer</code>、<code>MediaCrypto</code>、 <code>MediaDrm</code>、<code>Image</code>、<code>Surface</code>一起使用）。</p><p>以下是 MediaCodec 的一些关键概念和用法：</p><ol><li><p>创建和配置 MediaCodec：首先，需要根据所需的编解码器类型（例如 H.264、VP8、Opus 等）创建一个 MediaCodec 实例。接下来，通过 MediaFormat 对象指定编解码器的一些参数，如分辨率、帧率、码率等。然后，使用 <code>configure()</code> 方法配置 MediaCodec。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 1. 创建和配置 MediaCodec</span>
            <span class="token class-name">MediaCodecInfo</span> codecInfo <span class="token operator">=</span> <span class="token function">selectCodec</span><span class="token punctuation">(</span><span class="token constant">MIME_TYPE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>codecInfo <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;No codec found for &quot;</span> <span class="token operator">+</span> <span class="token constant">MIME_TYPE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">MediaFormat</span> format <span class="token operator">=</span> <span class="token class-name">MediaFormat</span><span class="token punctuation">.</span><span class="token function">createVideoFormat</span><span class="token punctuation">(</span><span class="token constant">MIME_TYPE</span><span class="token punctuation">,</span> <span class="token constant">WIDTH</span><span class="token punctuation">,</span> <span class="token constant">HEIGHT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            format<span class="token punctuation">.</span><span class="token function">setInteger</span><span class="token punctuation">(</span><span class="token class-name">MediaFormat</span><span class="token punctuation">.</span><span class="token constant">KEY_COLOR_FORMAT</span><span class="token punctuation">,</span> <span class="token class-name">MediaCodecInfo<span class="token punctuation">.</span>CodecCapabilities<span class="token punctuation">.</span>COLOR_FormatSurface</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            format<span class="token punctuation">.</span><span class="token function">setInteger</span><span class="token punctuation">(</span><span class="token class-name">MediaFormat</span><span class="token punctuation">.</span><span class="token constant">KEY_BIT_RATE</span><span class="token punctuation">,</span> <span class="token constant">BIT_RATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            format<span class="token punctuation">.</span><span class="token function">setInteger</span><span class="token punctuation">(</span><span class="token class-name">MediaFormat</span><span class="token punctuation">.</span><span class="token constant">KEY_FRAME_RATE</span><span class="token punctuation">,</span> <span class="token constant">FRAME_RATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            format<span class="token punctuation">.</span><span class="token function">setInteger</span><span class="token punctuation">(</span><span class="token class-name">MediaFormat</span><span class="token punctuation">.</span><span class="token constant">KEY_I_FRAME_INTERVAL</span><span class="token punctuation">,</span> <span class="token constant">IFRAME_INTERVAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            encoder <span class="token operator">=</span> <span class="token class-name">MediaCodec</span><span class="token punctuation">.</span><span class="token function">createByCodecName</span><span class="token punctuation">(</span>codecInfo<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            encoder<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">MediaCodec</span><span class="token punctuation">.</span><span class="token constant">CONFIGURE_FLAG_ENCODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            encoder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to initialize encoder&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>输入和输出缓冲区：MediaCodec 有两个缓冲区队列，一个用于输入，另一个用于输出。输入缓冲区用于接收原始数据（例如从摄像头捕获的视频帧），输出缓冲区用于存储编码后的数据。在编解码过程中，需要将这些缓冲区填充或消费。</p><p><img src="http://devyk.top/2022/202304161447304.png" alt=""></p></li><li><p>编码器工作模式：MediaCodec 支持两种工作模式，分别是同步和异步。在同步模式下，需要手动管理输入和输出缓冲区。在异步模式下，通过设置回调函数（<code>MediaCodec.Callback</code>），可以在编解码事件发生时自动通知应用程序。</p><p><strong>同步：</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">MediaCodec</span> codec <span class="token operator">=</span> <span class="token class-name">MediaCodec</span><span class="token punctuation">.</span><span class="token function">createByCodecName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
 codec<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">MediaFormat</span> outputFormat <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// option B</span>
 codec<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> inputBufferId <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">dequeueInputBuffer</span><span class="token punctuation">(</span>timeoutUs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>inputBufferId <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ByteBuffer</span> inputBuffer <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getInputBuffer</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// fill inputBuffer with valid data</span>
    …
    codec<span class="token punctuation">.</span><span class="token function">queueInputBuffer</span><span class="token punctuation">(</span>inputBufferId<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> outputBufferId <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">dequeueOutputBuffer</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>outputBufferId <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ByteBuffer</span> outputBuffer <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputBuffer</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">MediaFormat</span> bufferFormat <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputFormat</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// option A</span>
    <span class="token comment">// bufferFormat is identical to outputFormat</span>
    <span class="token comment">// outputBuffer is ready to be processed or rendered.</span>
    …
    codec<span class="token punctuation">.</span><span class="token function">releaseOutputBuffer</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>outputBufferId <span class="token operator">==</span> <span class="token class-name">MediaCodec</span><span class="token punctuation">.</span><span class="token constant">INFO_OUTPUT_FORMAT_CHANGED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Subsequent data will conform to new format.</span>
    <span class="token comment">// Can ignore if using getOutputFormat(outputBufferId)</span>
    outputFormat <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// option B</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 codec<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 codec<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>异步(推荐使用):</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">MediaCodec</span> codec <span class="token operator">=</span> <span class="token class-name">MediaCodec</span><span class="token punctuation">.</span><span class="token function">createByCodecName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">MediaFormat</span> mOutputFormat<span class="token punctuation">;</span> <span class="token comment">// member variable</span>
 codec<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MediaCodec<span class="token punctuation">.</span>Callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">void</span> <span class="token function">onInputBufferAvailable</span><span class="token punctuation">(</span><span class="token class-name">MediaCodec</span> mc<span class="token punctuation">,</span> <span class="token keyword">int</span> inputBufferId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ByteBuffer</span> inputBuffer <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getInputBuffer</span><span class="token punctuation">(</span>inputBufferId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// fill inputBuffer with valid data</span>
    …
    codec<span class="token punctuation">.</span><span class="token function">queueInputBuffer</span><span class="token punctuation">(</span>inputBufferId<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">void</span> <span class="token function">onOutputBufferAvailable</span><span class="token punctuation">(</span><span class="token class-name">MediaCodec</span> mc<span class="token punctuation">,</span> <span class="token keyword">int</span> outputBufferId<span class="token punctuation">,</span> …<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ByteBuffer</span> outputBuffer <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputBuffer</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">MediaFormat</span> bufferFormat <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputFormat</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// option A</span>
    <span class="token comment">// bufferFormat is equivalent to mOutputFormat</span>
    <span class="token comment">// outputBuffer is ready to be processed or rendered.</span>
    …
    codec<span class="token punctuation">.</span><span class="token function">releaseOutputBuffer</span><span class="token punctuation">(</span>outputBufferId<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">void</span> <span class="token function">onOutputFormatChanged</span><span class="token punctuation">(</span><span class="token class-name">MediaCodec</span> mc<span class="token punctuation">,</span> <span class="token class-name">MediaFormat</span> format<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Subsequent data will conform to new format.</span>
    <span class="token comment">// Can ignore if using getOutputFormat(outputBufferId)</span>
    mOutputFormat <span class="token operator">=</span> format<span class="token punctuation">;</span> <span class="token comment">// option B</span>
  <span class="token punctuation">}</span>
 
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
  <span class="token punctuation">}</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">void</span> <span class="token function">onCryptoError</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 codec<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>
 mOutputFormat <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">getOutputFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// option B</span>
 codec<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// wait for processing to complete</span>
 codec<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 codec<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>MediaCodec 与 Surface：对于视频编解码，MediaCodec 可以与 Surface 对象一起使用，以便使用 GPU 进行高效处理。通过将编解码器与 Surface 关联，可以将图像数据直接从 Surface 传输到编解码器，而无需在 CPU 和 GPU 之间复制数据。这可以提高性能并降低功耗。</p><p>可使用如下 api 进行创建一个输入 surface</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Surface</span> createInputSurface <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>返回的 inputSurface 可与 EGL 进行绑定，与 OpenGL ES 再进行关联。 sample 可以参考这个开源库 <a href="https://github.com/google/grafika/blob/master/app/src/main/java/com/android/grafika/RecordFBOActivity.java" target="_blank" rel="noopener noreferrer">grafika<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>开始和停止编解码：配置完 MediaCodec 后，调用 <code>start()</code> 方法开始编解码过程。在完成编解码任务后，需要调用 <code>stop()</code> 方法停止编解码器，并使用 <code>release()</code> 方法释放资源。</p></li><li><p>错误处理：在使用 MediaCodec 时，可能会遇到各种类型的错误，如不支持的编解码格式、资源不足等。为了确保应用程序的稳定性，需要妥善处理这些错误情况。</p></li></ol><p>总之，MediaCodec 是 Android 中处理音视频编解码的关键组件。了解其基本概念和用法有助于构建高效、稳定的媒体应用程序。</p><h2 id="webrtc-中如何使用硬件编码器" tabindex="-1"><a class="header-anchor" href="#webrtc-中如何使用硬件编码器" aria-hidden="true">#</a> webrtc 中如何使用硬件编码器？</h2><p>由于在 WebRTC 中优先使用的是 VP8 编码器，所以我们想要分析 Android 上硬件编码的流程，需要先支持 h264 的硬件编码</p><ol><li><p>创建 PeerConnectionFactory 时设置视频编码器</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>
    private PeerConnectionFactory createPeerConnectionFactory() {
        PeerConnectionFactory.initialize(
                PeerConnectionFactory.InitializationOptions.builder(applicationContext)
                        .setEnableInternalTracer(true)
                        .createInitializationOptions());

        PeerConnectionFactory.Options options = new PeerConnectionFactory.Options();
        DefaultVideoEncoderFactory defaultVideoEncoderFactory =
                new DefaultVideoEncoderFactory(
                        rootEglBase.getEglBaseContext(), true /* enableIntelVp8Encoder */, true);
        DefaultVideoDecoderFactory defaultVideoDecoderFactory =
                new DefaultVideoDecoderFactory(rootEglBase.getEglBaseContext());

        return PeerConnectionFactory.builder()
                .setOptions(options)
                .setVideoEncoderFactory(defaultVideoEncoderFactory)
                .setVideoDecoderFactory(defaultVideoDecoderFactory)
                .createPeerConnectionFactory();
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在 createOffer / createAnswer 将 SDP 中 m=video 的 h264 playload 编号放在第一位</p><p>这部分代码可以参考 <a href="https://github.com/yangkun19921001/OpenRTCClient/blob/develop/examples/android_gradle/AppRTCMobile/src/main/java/org/appspot/apprtc/PeerConnectionClient.java" target="_blank" rel="noopener noreferrer">preferCodec<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li></ol><h2 id="webrtc-中编码器是如何初始化的" tabindex="-1"><a class="header-anchor" href="#webrtc-中编码器是如何初始化的" aria-hidden="true">#</a> webrtc 中编码器是如何初始化的？</h2><p>通过上一个问题得知，我们使用的是 <strong>DefaultVideoEncoderFactory</strong> 默认编码器，内容其实就是使用的硬件能力</p><p><img src="http://devyk.top/2022/202304161542395.png" alt=""></p><p>内部实例化了一个 <strong>HardwareVideoEncoderFactory</strong> ，我们在 <strong>DefaultVideoEncoderFactory</strong> 中看到了 <code>createEncoder</code> 函数，这里的内部就是实例化 HardwareVideoEncoder 的地方，我先 debug 下看下是哪里调用的，如下图所示，</p><p>下图的第一点可以发现底层传递过来的已经是 h264 编码器的信息了。</p><p><img src="http://devyk.top/2022/202304161631092.png" alt=""></p><p>发现调用栈并没有在 java 端，那肯定在 native 端了，我们可以通过 <strong>createPeerConnectionFactory</strong> 查看下调用</p><ol><li><p>将 videoEnvoderFactory 引用传递到 native</p><p><img src="http://devyk.top/2022/202304161631311.png" alt=""></p></li><li><p>Native 入口在 PeerConnectionFactory_jni.h</p><p><img src="http://devyk.top/2022/202304161633190.png" alt=""></p></li><li><p>根据调用栈，发现将 jencoder_factory 包装到了 <strong>CreateVideoEncoderFactory</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ScopedJavaLocalRef&lt;jobject&gt; CreatePeerConnectionFactoryForJava(
    JNIEnv* jni,
    const JavaParamRef&lt;jobject&gt;&amp; jcontext,
    const JavaParamRef&lt;jobject&gt;&amp; joptions,
    rtc::scoped_refptr&lt;AudioDeviceModule&gt; audio_device_module,
    rtc::scoped_refptr&lt;AudioEncoderFactory&gt; audio_encoder_factory,
    rtc::scoped_refptr&lt;AudioDecoderFactory&gt; audio_decoder_factory,
    const JavaParamRef&lt;jobject&gt;&amp; jencoder_factory,
    const JavaParamRef&lt;jobject&gt;&amp; jdecoder_factory,
    rtc::scoped_refptr&lt;AudioProcessing&gt; audio_processor,
    std::unique_ptr&lt;FecControllerFactoryInterface&gt; fec_controller_factory,
    std::unique_ptr&lt;NetworkControllerFactoryInterface&gt;
        network_controller_factory,
    std::unique_ptr&lt;NetworkStatePredictorFactoryInterface&gt;
        network_state_predictor_factory,
    std::unique_ptr&lt;NetEqFactory&gt; neteq_factory) {

...

  media_dependencies.video_encoder_factory =
      absl::WrapUnique(CreateVideoEncoderFactory(jni, jencoder_factory));

...
}

VideoEncoderFactory* CreateVideoEncoderFactory(
    JNIEnv* jni,
    const JavaRef&lt;jobject&gt;&amp; j_encoder_factory) {
  return IsNull(jni, j_encoder_factory)
             ? nullptr
             : new VideoEncoderFactoryWrapper(jni, j_encoder_factory);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过一系列的调用，我们发现java 端的引用，被封装成了 c++ 端的 <strong>VideoEncoderFactoryWrapper</strong> ,我们看一下它的构造函数</p><p><img src="http://devyk.top/2022/202304161644418.png" alt=""></p><p>主要就是通过 jni 调用 java 端的代码，用以获取当前设备所支持的编码器和编码器的信息</p></li><li><p>猜测既然在 Native 中包装了 java 端 VideoEncoder.java 的引用，那么肯定也有对应的 CreateEncoder 函数</p><p><img src="http://devyk.top/2022/202304161653222.png" alt=""></p><p>我们在 video_encoder_factory_wrapper.h 中看到了我们想要的函数，我们看下它的实现</p><p><img src="http://devyk.top/2022/202304161657500.png" alt=""></p><p><img src="http://devyk.top/2022/202304161657499.png" alt=""> 这不就是我们找到了 createEncoder jni 调用的入口吗？那么是什么时候调用的呢？我们进行 debug 一下</p><p><img src="http://devyk.top/2022/202304161700450.png" alt=""></p><p>它的调用栈是媒体协商成功后，根据发起方的编码器来匹配，目前匹配到了最优的 H264 编码，然后进行创建 H264 编码器</p><p><img src="http://devyk.top/2022/202304161704320.gif" alt=""></p><p>此时，我们已经又回到了 java 端的 createEncoder 代码，我们来看下是怎么对 MediaCodec 初始化的</p></li><li><p>MediaCodec 核心初始化代码</p><p>在 HardwareVideoEncoderFactory 中的 createEncoder 中</p><p><img src="http://devyk.top/2022/202304161708921.png" alt=""></p><p>上面的逻辑是判断 MediaCodec 是否只是 baseline 和 high ,如果都不支持返回空，反之返回 HardwareVideoEncoder 实例，该实例又返回给了 native ，然后转为了 native 的智能指针 <code>std::unique_ptr&lt;VideoEncoder&gt;</code> 的实体 VideoEncoderWrapper</p><p><img src="http://devyk.top/2022/202304161718584.png" alt=""></p><p>通过 <code>debug ，我们找到了在 native jni 执行 initEncode</code> 的入口函数</p><p><img src="http://devyk.top/2022/202304161719529.png" alt=""></p><p>通过媒体协商后，我们得到了编码器配置的一些参数</p><p><img src="http://devyk.top/2022/202304161723236.png" alt=""></p><p>内部执行了 <strong>initEncodeInternal</strong> ,我们看下具体实现</p><p><img src="http://devyk.top/2022/202304161730969.png" alt=""></p><p>这里就是我们所熟悉的 MediaCodec 编码配置了，根据上面的序号我们知道，先根据媒体协商后的编码器名称来创建一个 MediaCodec 对象，然后配置一些必要的参数，最后启动编码器.</p><p>下一步我们开始分析 webrtc 如何将采集到的纹理送入到编码器中进行编码的。还没有看 <a href="https://juejin.cn/post/7139488477892050975#heading-4" target="_blank" rel="noopener noreferrer">WebRTC 源码分析 (一) Android 相机采集<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 需要去温习一下。</p></li></ol><h2 id="webrtc-中是如何将数据送入编码器的" tabindex="-1"><a class="header-anchor" href="#webrtc-中是如何将数据送入编码器的" aria-hidden="true">#</a> webrtc 中是如何将数据送入编码器的？</h2><p>WebRTC 使用 <code>VideoEncoder</code> 接口来进行视频编码，该接口定义了一个用于编码视频帧的方法：<code>encode(VideoFrame frame, EncodeInfo info)</code>。WebRTC 提供了一个名为 <code>HardwareVideoEncoder</code> 的类，该类实现了 <code>VideoEncoder</code> 接口，并使用 MediaCodec 对视频帧进行编码。</p><p>在 <code>HardwareVideoEncoder</code> 类中，WebRTC 将 <code>VideoFrame</code> 对象转换为与 MediaCodec 关联的 <code>Surface</code> 的纹理。这是通过使用 <code>EglBase</code> 类创建一个 EGL 环境，并使用该环境将 <code>VideoFrame</code> 的纹理绘制到 <code>Surface</code> 上来实现的。</p><p>为了更好的理解 MediaCodec createInputSurface 和 OpenGL ES 、EGL 的关系，我简单画了一个架构图。如下所示:</p><p><img src="http://devyk.top/2022/202304162036455.png" alt=""></p><p>EGL、OpenGL ES、 InputSurface 关系流程：</p><ol><li>使用 OpenGL ES 绘制图像。</li><li>EGL 管理和连接 OpenGL ES 渲染的表面。</li><li>通过 Input Surface，将 OpenGL ES 绘制的图像传递给 MediaCodec。</li><li>MediaCodec 对接收到的图像数据进行编码。</li></ol><p>我们看下具体的流程吧，通过上一篇文章得知， <a href="https://juejin.cn/post/7139488477892050975#heading-4" target="_blank" rel="noopener noreferrer">WebRTC 源码分析 (一) Android 相机采集<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 采集到相机数据后，会提交给 VideoStreamEncoder ，我们来看一下堆栈</p><p><img src="http://devyk.top/2022/202304161922718.png" alt=""></p><p>根据上面流程得知，采集到的 VideoFrame 会提交给 VideoStreamEncoder::OnFrame 然后经过调用 EncodeVideoFrame 会执行到 VideoEncoder.java 的包装类,webrtc::jni::VideoEnacoderWrapper::Encode 函数，最后通过 jni 将(videoFrame,encodeInfo) 回调给了 java 端。</p><p>接下来我们看 java 端如何处理的 VideoFrame</p><p><img src="http://devyk.top/2022/202304161936223.png" alt=""></p><p>该函数的核心是判断是否使用 surface 模式进行编码，如果条件成立调用 encodeTextureBuffer 进行纹理编码，</p><p><img src="http://devyk.top/2022/202304161940918.png" alt=""></p><p>我们先看上图的第一步,</p><p><img src="http://devyk.top/2022/202304161947167.png" alt=""></p><p>第一步的 1-3 小点主要是通过 OpenGL ES 将 OES 纹理数据绘制出来，然后第二大步的 <strong>textureEglBase.swapBuffers(...)</strong> 主要是将 OpenGL ES 处理后的图像数据提交给 EGLSurface 。经过这些操作后纹理数据就提交给 MediaCodec 的 inputsurface 了。</p><h2 id="webrtc-是如何获取编码后的数据" tabindex="-1"><a class="header-anchor" href="#webrtc-是如何获取编码后的数据" aria-hidden="true">#</a> webrtc 是如何获取编码后的数据？</h2><p>在 <code>HardwareVideoEncoder</code> 类中，使用 MediaCodec 同步模式进行获取编码后的数据。当数据可用时，会调用 <code>callback.onEncodedFrame(encodedImage, new CodecSpecificInfo());</code> 方法,然后将编码后的帧传递给 WebRTC 引擎。WebRTC 引擎会对编码后的帧进行进一步处理，如封装 RTP 包、发送到对端等。</p><p>主要流程如下:</p><p><img src="http://devyk.top/2022/202304162101149.png" alt=""></p><p>第一步有点印象吧？对，就是在编码器初始化的时候会开启一个循环获取解码数据的线程，我们分析下 deliverEncodedImage 函数的实现逻辑</p><p><img src="http://devyk.top/2022/202304162109204.png" alt=""></p><p>这段代码的主要功能是从编解码器 (MediaCodec) 中获取编码后的视频帧，并对关键帧进行处理。以下是代码的逐步分析：</p><ol><li><p>定义一个 <code>MediaCodec.BufferInfo</code> 对象，用于存储输出缓冲区的元信息。</p></li><li><p>调用 <code>codec.dequeueOutputBuffer()</code> 方法来获取编码后的输出缓冲区索引。如果索引小于 0，则有特殊含义。比如 <code>MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED</code> 表示输出缓冲区已更改，此时需要重新获取输出缓冲区。</p></li><li><p>使用索引获取编码后的输出缓冲区 (ByteBuffer)。</p></li><li><p>设置缓冲区的位置 (position) 和限制 (limit)，以便读取数据。</p></li><li><p>检查 <code>info.flags</code> 中的 <code>MediaCodec.BUFFER_FLAG_CODEC_CONFIG</code> 标志。如果存在，表示当前帧为编解码器配置帧。这种情况下，将配置帧数据存储在 <code>configBuffer</code> 中。</p></li><li><p>如果当前帧不是配置帧，则执行以下操作：</p><p>6.1 查看当前是否重新配置编码码率，如果是就更新比特率。</p><p>6.2 检查当前帧是否为关键帧。如果 <code>info.flags</code> 中的 <code>MediaCodec.BUFFER_FLAG_SYNC_FRAME</code> 标志存在，则表示当前帧为关键帧。 6.3 对于 H.264 编码的关键帧，将 SPS 和 PPS NALs 数据附加到帧的开头。创建一个新的缓冲区，将 <code>configBuffer</code> 和编码后的输出缓冲区的内容复制到新缓冲区中。</p><p>6.4 根据帧类型 (关键帧或非关键帧)，创建一个 <code>EncodedImage</code> 对象。在释放输出缓冲区时，确保不抛出任何异常。</p><p>6.5 调用 <code>callback.onEncodedFrame()</code> 方法传递编码后的图像和编解码器特定信息。</p><p>6.6 释放 <code>EncodedImage</code> 对象。</p></li></ol><p>当遇到异常 (例如 <code>IllegalStateException</code>) 时，代码将记录错误信息。</p><p>总之，这段代码的目标是从 MediaCodec 中获取编码后的视频帧，对关键帧进行处理，并将结果传递给回调函数。</p><p>对，该疑问的答案就是 6.5 它将编码后的数据通过 onEncodedFrame 告知了 webrtc 引擎。由于后面的处理不是本章的重点，所以不再分析。</p><h2 id="webrtc-是如何做码流控制的" tabindex="-1"><a class="header-anchor" href="#webrtc-是如何做码流控制的" aria-hidden="true">#</a> webrtc 是如何做码流控制的？</h2><p>WebRTC 的码流控制包括拥塞控制和比特率自适应两个主要方面。这里只简单介绍下概念，及 Android 是如何配合 webrtc 来动态修改码率的。</p><ol><li>拥塞控制 (Congestion Control)： 拥塞控制主要关注在不引起网络拥塞的情况下传输尽可能多的数据。WebRTC 实现了基于 Google Congestion Control (GCC) 的拥塞控制算法，它也被称为 Send Side Bandwidth Estimation（发送端带宽估计）。此算法根据丢包率、往返时间 (RTT) 和接收端的 ACK 信息来调整发送端的码率。拥塞控制算法会持续监测网络状况，并根据需要动态调整发送码率。</li><li>比特率自适应 (Bitrate Adaptation)： 比特率自适应关注如何根据网络条件和设备性能调整视频编码参数，以实现最佳的视频质量。</li></ol><p>当比特率发生变化时，WebRTC 会调用 <code>VideoEncoder.setRateAllocation()</code> 方法来通知更新比特率。</p><p>在编码的时候，其实在上一个疑问中已经知道了如何调节码率。判断条件是当当前的码率与需要调节的码率不匹配时，调用如下代码进行更新:</p><p><img src="http://devyk.top/2022/202304162147792.png" alt=""></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本文深入剖析了 WebRTC 在 Android 平台上是如何使用 MediaCodec 对视频数据进行编码的，以及整个编码过程中 webrtc native 与 java 的流程交互。首先回顾了 Android MediaCodec 的概念和基础使用，包括创建和配置 MediaCodec、输入和输出缓冲区、编码器工作模式以及 MediaCodec 与 Surface 的关系。然后，通过具体的代码示例，详细说明了在 WebRTC 中如何实现视频数据的编解码。并通过几个疑问的方式从源码的角度了解到了整个编码流程。希望通过此文能帮助读者更好地理解 WebRTC Android 编码技术。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2><ul><li><a href="https://blog.piasy.com/2017/08/08/WebRTC-Android-HW-Encode-Video/index.html" target="_blank" rel="noopener noreferrer">WebRTC Native 源码导读（三）：安卓视频硬编码实现分析<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li>https://developer.android.com/reference/android/media/MediaCodec.html</li></ul></div><!--[--><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/yangkun19921001/AudioVideoBlogDoc/edit/main/docs/pages/webrtc/WebRTC源码分析(二)Android视频硬件编码.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: yang1001yk@gmail.com">make</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)Android%E7%9B%B8%E6%9C%BA%E9%87%87%E9%9B%86.html" class="" aria-label="WebRTC 源码分析 (一) Android 相机采集"><!--[--><!--]--> WebRTC 源码分析 (一) Android 相机采集 <!--[--><!--]--></a></span><span class="next"><a href="/AudioVideoBlog/pages/webrtc/WebRTC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)PeerConnection%20Client.html" class="" aria-label="WebRTC源码分析(三)PeerConnection Client"><!--[--><!--]--> WebRTC源码分析(三)PeerConnection Client <!--[--><!--]--></a></span></p></nav><!--[--><!--[--><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--]--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script src="/AudioVideoBlog/assets/js/v-1fa12de2.3e0cb076.js" defer></script><script src="/AudioVideoBlog/assets/js/runtime~app.05409ea8.js" defer></script><script src="/AudioVideoBlog/assets/js/48.afaf53c5.js" defer></script><script src="/AudioVideoBlog/assets/js/app.d2cafc2e.js" defer></script>
  </body>
</html>
